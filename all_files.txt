Plik: ./character.py
import json
import random
from typing import Dict

class Character:
    def __init__(self, char_id, data):
        self.id = char_id
        self.name = data['name']
        self.description = data['description']
        self.location = data['location']
        self.dialogues = data.get('dialogues', [])
        self.inventory = data.get('inventory', [])  # Lista ID przedmiotów
        self.health = data.get('health', 50)
        self.strength = data.get('strength', 5)
        self.defense = data.get('defense', 2)
        self.exp = data.get('exp', 20)
        self.is_enemy = data.get('is_enemy', False)

class Merchant(Character):
    def __init__(self, char_id, data):
        super().__init__(char_id, data)
        self.prices = data.get('prices', {})  # Ceny sprzedaży
        self.buy_multiplier = 0.5  # Mnożnik ceny przy skupie (50% wartości)

    def get_sell_price(self, item_id):
        """Zwraca cenę sprzedaży przedmiotu."""
        return self.prices.get(item_id, 50)  # Domyślna cena 50 złota

    def get_buy_price(self, item_id):
        """Zwraca cenę skupu przedmiotu."""
        return int(self.get_sell_price(item_id) * self.buy_multiplier)

    def sell_item(self, item_id, player, items):
        """Sprzedaje przedmiot graczowi."""
        if item_id not in self.inventory:
            return False, "Nie mam tego przedmiotu na sprzedaż!"

        price = self.get_sell_price(item_id)
        if player.gold < price:
            return False, f"Nie masz wystarczająco złota! (Potrzeba: {price})"

        success, message = player.inventory.add_item(item_id)
        if success:
            player.gold -= price
            self.inventory.remove(item_id)
            return True, f"Kupiłeś {items.get_item(item_id).name} za {price} złota!"
        return False, message

    def buy_item(self, item_id, player, items):
        """Skupuje przedmiot od gracza."""
        if item_id not in player.inventory.items:
            return False, "Nie masz tego przedmiotu!"

        price = self.get_buy_price(item_id)
        success, message = player.inventory.remove_item(item_id)
        if success:
            player.gold += price
            self.inventory.append(item_id)
            return True, f"Sprzedałeś {items.get_item(item_id).name} za {price} złota!"
        return False, message

    def show_inventory(self, items):
        """Wyświetla towary na sprzedaż."""
        print(f"\n=== Towary {self.name} ===")
        if not self.inventory:
            print("Nie mam nic na sprzedaż!")
            return

        for item_id in self.inventory:
            item = items.get_item(item_id)
            price = self.get_sell_price(item_id)
            print(f"- {item.name}: {price} złota - {item.description}")

class Enemy(Character):
    def __init__(self, char_id, data):
        super().__init__(char_id, data)
        self.is_enemy = True
        self.loot_table = data.get('loot_table', {})  # Słownik {item_id: szansa_na_drop}

    def get_loot(self):
        """Zwraca listę przedmiotów z przeciwnika po jego śmierci."""
        loot = []
        # Sprawdź każdy przedmiot z podstawowego inventory
        if self.inventory:
            loot.extend(self.inventory)
        
        # Sprawdź przedmioty z loot_table (jeśli są)
        for item_id, chance in self.loot_table.items():
            if random.random() < chance:
                loot.append(item_id)
        
        return loot

class CharacterManager:
    def __init__(self, data_file='data/characters.json'):
        with open(data_file, 'r', encoding='utf-8') as f:
            data = json.load(f)['characters']
        self.characters: Dict[str, Character] = {}
        for char_id, char_data in data.items():
            if char_data.get('is_enemy', False):
                self.characters[char_id] = Enemy(char_id, char_data)
            elif char_data.get('prices'):
                self.characters[char_id] = Merchant(char_id, char_data)
            else:
                self.characters[char_id] = Character(char_id, char_data)

    def get_characters_in_location(self, location_id, include_enemies=False):
        return [char for char in self.characters.values() if char.location == location_id and (include_enemies or not char.is_enemy)]

    def get_character_by_name(self, name):
        for char in self.characters.values():
            if char.name.lower() == name.lower():
                return char
        return NonePlik: ./combat.py
# combat.py
import tkinter as tk
from tkinter import ttk, scrolledtext
import random
from typing import Dict, Optional, Tuple, List
import logging
from config import game_config

logger = logging.getLogger(__name__)

class CombatSystem:
    """Główny system walki w grze."""
    
    def __init__(self):
        self.active_combats: Dict[str, 'CombatInstance'] = {}
        self.combat_history = []
        self.global_modifiers = {}

    def start_combat(self, player, enemy) -> 'CombatInstance':
        """Rozpoczyna nową walkę."""
        combat_id = f"{player.id}_{enemy.id}_{len(self.combat_history)}"
        combat = CombatInstance(player, enemy, combat_id)
        self.active_combats[combat_id] = combat
        
        # Zapisz w historii
        self.combat_history.append({
            'combat_id': combat_id,
            'player_id': player.id,
            'enemy_id': enemy.id,
            'start_time': combat.start_time,
            'status': 'in_progress'
        })
        
        return combat

    def end_combat(self, combat_id: str, winner=None):
        """Kończy walkę."""
        if combat_id in self.active_combats:
            combat = self.active_combats[combat_id]
            combat.end(winner)
            
            # Aktualizuj historię
            for record in self.combat_history:
                if record['combat_id'] == combat_id:
                    record['end_time'] = combat.end_time
                    record['status'] = 'completed'
                    record['winner'] = winner.id if winner else None
                    record['duration'] = combat.end_time - combat.start_time
                    break
                        
            del self.active_combats[combat_id]

    def update(self, game_time: float):
        """Aktualizuje wszystkie aktywne walki."""
        for combat_id, combat in list(self.active_combats.items()):
            if combat.is_finished():
                self.end_combat(combat_id, combat.get_winner())
            else:
                combat.update(game_time)

    def get_combat_stats(self, entity_id: str) -> dict:
        """Zwraca statystyki walk dla danej jednostki."""
        stats = {
            'total_fights': 0,
            'victories': 0,
            'defeats': 0,
            'total_damage_dealt': 0,
            'total_damage_taken': 0,
            'longest_fight': 0,
            'fastest_victory': float('inf'),
            'most_damage_in_fight': 0
        }
        
        for record in self.combat_history:
            if record['player_id'] == entity_id or record['enemy_id'] == entity_id:
                stats['total_fights'] += 1
                
                if record['status'] == 'completed':
                    if record['winner'] == entity_id:
                        stats['victories'] += 1
                        if record['duration'] < stats['fastest_victory']:
                            stats['fastest_victory'] = record['duration']
                    else:
                        stats['defeats'] += 1
                        
                    if record['duration'] > stats['longest_fight']:
                        stats['longest_fight'] = record['duration']
                        
        return stats

class CombatInstance:
    """Reprezentuje pojedynczą instancję walki."""
    
    def __init__(self, player, enemy, combat_id: str):
        self.combat_id = combat_id
        self.player = player
        self.enemy = enemy
        self.start_time = game_config.get('game_time', 0)
        self.end_time = None
        self.turn = 1
        self.last_action_time = self.start_time
        self.combat_log = []
        self.active_effects = []
        self.ability_cooldowns = {}  # Dodane pole dla cooldownów
        
        # Stan walki
        self.player_status = {
            'stamina': 100,
            'defense_bonus': 0,
            'status_effects': [],
            'combo_counter': 0,
            'dodge_chance': player.stats.dodge_chance,
            'crit_chance': player.stats.critical_chance
        }
        
        self.enemy_status = {
            'defense_bonus': 0,
            'status_effects': [],
            'next_action': None,
            'aggression_level': random.uniform(0.5, 1.5)
        }

    def update(self, game_time: float):
        """Aktualizuje stan walki."""
        if self.is_finished():
            return
            
        # Aktualizacja efektów statusu
        self._update_status_effects(game_time)
        
        # Regeneracja zasobów
        self._update_resources()
        
        # Aktualizuj cooldowny
        self._update_cooldowns(game_time)
        
        # Sprawdź czy czas na następną turę
        if game_time - self.last_action_time >= game_config.get('combat.turn_duration', 1.0):
            self._process_turn()

    def _update_cooldowns(self, game_time: float):
        """Aktualizuje cooldowny zdolności."""
        for ability_id in list(self.ability_cooldowns.keys()):
            if game_time >= self.ability_cooldowns[ability_id]:
                del self.ability_cooldowns[ability_id]

    def _try_dodge(self) -> bool:
        """Sprawdza czy udało się uniknąć ataku."""
        dodge_chance = self.current_stats.dodge_chance
        if 'dodge_bonus' in self.active_effects:
            dodge_chance += self.active_effects['dodge_bonus']
        return random.random() < dodge_chance

    def _initialize_combat(self):
        """Inicjalizuje walkę."""
        # Ustaw stany walki
        self.player.in_combat = True
        self.enemy.in_combat = True
        
        # Aplikuj efekty przedwalką
        self._apply_pre_combat_effects()
        
        # Zapisz log rozpoczęcia
        self.add_combat_log(
            f"Rozpoczyna się walka między {self.player.name} a {self.enemy.name}!",
            "system"
        )
        
        # Opisz przeciwnika
        self.add_combat_log(self.enemy.description, "info")

    def _apply_pre_combat_effects(self):
        """Aplikuje efekty przed rozpoczęciem walki."""
        # Efekty ekwipunku
        if hasattr(self.player, 'equipment'):
            for item in self.player.equipment.values():
                if item and 'combat_start_effect' in item.properties:
                    self._apply_equipment_effect(item.properties['combat_start_effect'])

        # Efekty umiejętności
        if hasattr(self.player, 'get_active_effects'):
            for effect in self.player.get_active_effects():
                if effect.trigger == 'combat_start':
                    self._apply_status_effect(effect)

    

    def _process_turn(self):
        """Przetwarza pojedynczą turę walki."""
        self.combat_stats['rounds'] += 1
        
        # Akcja przeciwnika
        enemy_action = self.enemy.choose_action(self)
        self._execute_enemy_action(enemy_action)
        
        # Sprawdź warunki końca walki
        if self._check_combat_end():
            return
            
        self.turn += 1
        self.last_action_time = game_config.get('game_time', 0)

    def handle_player_action(self, action_type: str, **kwargs) -> Tuple[bool, str]:
        """Obsługuje akcję gracza."""
        if action_type == "attack":
            return self._handle_player_attack(**kwargs)
        elif action_type == "defend":
            return self._handle_player_defend()
        elif action_type == "use_ability":
            return self._handle_player_ability(kwargs.get('ability_name'))
        elif action_type == "use_item":
            return self._handle_use_item(kwargs.get('item_id'))
        elif action_type == "escape":
            return self._handle_escape_attempt()
        else:
            return False, "Nieznana akcja!"

    def _handle_player_attack(self, **kwargs) -> Tuple[bool, str]:
        """Obsługuje podstawowy atak gracza."""
        # Oblicz obrażenia bazowe
        base_damage = self.player.stats.strength
        if self.player.inventory and self.player.inventory.equipped.get('weapon'):
            weapon = self.player.inventory.equipped['weapon']
            base_damage += weapon.properties.get('damage', 0)
            
        # Sprawdź trafienie krytyczne
        is_crit = random.random() < self.player_status['crit_chance']
        if is_crit:
            base_damage *= 2
            self.combat_stats['critical_hits'] += 1
            self.add_combat_log("Krytyczne trafienie!", "success")
            
        # Oblicz końcowe obrażenia
        final_damage = max(1, base_damage - (self.enemy.stats.defense + self.enemy_status['defense_bonus']))
        
        # Zadaj obrażenia
        self.enemy.stats.health -= final_damage
        self.combat_stats['player_damage_dealt'] += final_damage
        
        # Aktualizuj combo
        self.player_status['combo_counter'] += 1
        if self.player_status['combo_counter'] >= 3:
            final_damage *= 1.2
            self.add_combat_log("Bonus za combo!", "success")
            
        self.add_combat_log(
            f"Zadajesz {final_damage:.1f} obrażeń{' (Krytyczne!)' if is_crit else ''}",
            "success"
        )
        
        return True, "Atak wykonany!"

    def _handle_player_defend(self) -> Tuple[bool, str]:
        """Obsługuje przyjęcie postawy obronnej."""
        defense_bonus = 5 + (self.player.get_skill_level('defense') * 1 
                           if hasattr(self.player, 'get_skill_level') else 0)
                           
        self.player_status['defense_bonus'] = defense_bonus
        self.player_status['stamina'] = min(100, self.player_status['stamina'] + 20)
        
        self.add_combat_log(
            f"Przyjmujesz postawę obronną (+{defense_bonus} do obrony)",
            "info"
        )
        return True, "Przyjęto postawę obronną!"

    def is_finished(self) -> bool:
        """Sprawdza czy walka się zakończyła."""
        return (not self.player.is_alive or not self.enemy.is_alive or 
                self.end_time is not None)

    def get_winner(self):
        """Zwraca zwycięzcę walki."""
        if not self.is_finished():
            return None
            
        if not self.enemy.is_alive:
            return self.player
        elif not self.player.is_alive:
            return self.enemy
            
        return None

    def end(self, winner=None):
        """Kończy walkę."""
        self.end_time = game_config.get('game_time', 0)
        
        # Resetuj stany walki
        self.player.in_combat = False
        self.enemy.in_combat = False
        
        # Usuń efekty walki
        self._clear_combat_effects()
        
        # Zapisz końcowy log
        if winner:
            self.add_combat_log(
                f"Walka zakończona! Zwycięzca: {winner.name}",
                "system"
            )
        else:
            self.add_combat_log("Walka przerwana!", "system")

    def add_combat_log(self, message: str, message_type: str = "info"):
        """Dodaje wpis do dziennika walki."""
        self.combat_log.append({
            'message': message,
            'type': message_type,
            'turn': self.turn,
            'time': game_config.get('game_time', 0)
        })

    def get_combat_log(self, last_n: Optional[int] = None) -> List[dict]:
        """Zwraca log walki."""
        if last_n is None:
            return self.combat_log
        return self.combat_log[-last_n:]

    def get_state(self) -> dict:
        """Zwraca obecny stan walki."""
        return {
            'combat_id': self.combat_id,
            'turn': self.turn,
            'player_status': self.player_status,
            'enemy_status': self.enemy_status,
            'combat_stats': self.combat_stats,
            'active_effects': self.active_effects,
            'is_finished': self.is_finished(),
            'winner': self.get_winner().id if self.get_winner() else None
        }


class CombatManager:
    def __init__(self, player, enemy, interface):
        self.player = player
        self.enemy = enemy
        self.interface = interface
        self.turn = 1
        self.player_stamina = 100
        self.abilities_cooldowns = {}
        self.combat_log = []
    
    def log_combat_event(self, message, message_type="info"):
        """Dodaje wpis do dziennika walki."""
        self.combat_log.append((message, message_type))
        self.interface.show_message(message, message_type)
    
    def calculate_damage(self, attacker, defender, is_player=True, ability_name: Optional[str] = None):
        """Oblicza obrażenia z efektami specjalnymi."""
        base_damage = max(0, attacker.strength - defender.defense)
        
        if is_player and ability_name:
            skill_level = self.player.get_skill_level("walka_mieczem")
            if skill_level > 0:
                base_damage += skill_level * 2
            
            if ability_name == "thrust" and skill_level >= 3:
                base_damage *= 2
                self.log_combat_event("Wykonujesz potężne pchnięcie!", "success")
            elif ability_name == "whirlwind" and skill_level >= 5:
                base_damage *= 1.5
                self.log_combat_event("Wykonujesz wirujący cios!", "success")

        # Szansa na unik
        dodge_chance = 0.10 if is_player else 0.05
        if random.random() < dodge_chance:
            self.log_combat_event(
                f"{'Unikasz ataku!' if is_player else f'{self.enemy.name} unika twojego ataku!'}", 
                "success" if is_player else "warning"
            )
            return 0, "UNIK!"
        
        # Szansa na trafienie krytyczne
        crit_chance = 0.15 if is_player else 0.05
        if random.random() < crit_chance:
            base_damage *= 2
            self.log_combat_event(
                f"{'Trafiasz krytycznie!' if is_player else f'{self.enemy.name} trafia cię krytycznie!'}",
                "success" if is_player else "error"
            )
            return base_damage, "KRYTYCZNE!"
        
        return base_damage, ""

    def use_ability(self, ability_name: str) -> Tuple[bool, str]:
        """Używa specjalnej umiejętności."""
        skill_level = self.player.get_skill_level("walka_mieczem")
        
        abilities = {
            "thrust": {
                "name": "Pchnięcie",
                "min_level": 3,
                "stamina_cost": 30,
                "cooldown": 3,
                "description": "Potężne pchnięcie zadające podwójne obrażenia"
            },
            "whirlwind": {
                "name": "Wirujący Cios",
                "min_level": 5,
                "stamina_cost": 50,
                "cooldown": 5,
                "description": "Obszarowy atak zadający 150% obrażeń"
            }
        }

        if ability_name not in abilities:
            return False, "Nieznana umiejętność!"

        ability = abilities[ability_name]
        
        if skill_level < ability["min_level"]:
            return False, f"Wymagany poziom umiejętności walki mieczem: {ability['min_level']}"
        
        if self.player_stamina < ability["stamina_cost"]:
            return False, f"Niewystarczająca stamina! (Potrzeba: {ability['stamina_cost']})"
        
        if ability_name in self.abilities_cooldowns and self.abilities_cooldowns[ability_name] > 0:
            return False, f"Umiejętność odnowi się za {self.abilities_cooldowns[ability_name]} tur!"

        self.player_stamina -= ability["stamina_cost"]
        self.abilities_cooldowns[ability_name] = ability["cooldown"]
        
        return True, f"Używasz {ability['name']}!"

    def show_combat_status(self):
        """Wyświetla status walki."""
        self.interface.clear_screen()
        self.interface.show_title(f"Walka - Tura {self.turn}", Fore.RED)
        
        # Status gracza
        print(f"\n{Fore.CYAN}=== Twój status ==={Style.RESET_ALL}")
        self.interface.draw_bar(
            self.player.health / self.player.max_health * 100,
            f"HP: {self.player.health}/{self.player.max_health}"
        )
        self.interface.draw_bar(
            self.player_stamina,
            f"Stamina: {self.player_stamina}/100",
            Fore.BLUE
        )

        # Status przeciwnika
        print(f"\n{Fore.RED}=== {self.enemy.name} ==={Style.RESET_ALL}")
        self.interface.draw_bar(
            self.enemy.health / self.enemy.max_health * 100,
            f"HP: {self.enemy.health}",
            Fore.RED
        )

        # Dziennik walki
        if self.combat_log:
            print(f"\n{Fore.YELLOW}=== Przebieg walki ==={Style.RESET_ALL}")
            for message, message_type in self.combat_log[-3:]:  # Pokazuj ostatnie 3 wydarzenia
                self.interface.show_message(message, message_type)

    def show_available_actions(self):
        """Wyświetla dostępne akcje w walce."""
        print(f"\n{Fore.GREEN}Dostępne akcje:{Style.RESET_ALL}")
        print("1. Atak podstawowy")
        print("2. Użyj przedmiotu")
        print("3. Spróbuj uciec")

        skill_level = self.player.get_skill_level("walka_mieczem")
        if skill_level >= 3:
            can_use_thrust = "thrust" not in self.abilities_cooldowns or self.abilities_cooldowns["thrust"] <= 0
            status = "" if can_use_thrust else f"(Odnowienie za {self.abilities_cooldowns['thrust']} tur)"
            print(f"4. Pchnięcie (30 staminy) {status}")

        if skill_level >= 5:
            can_use_whirlwind = "whirlwind" not in self.abilities_cooldowns or self.abilities_cooldowns["whirlwind"] <= 0
            status = "" if can_use_whirlwind else f"(Odnowienie za {self.abilities_cooldowns['whirlwind']} tur)"
            print(f"5. Wirujący Cios (50 staminy) {status}")

    def handle_player_turn(self):
        """Obsługuje turę gracza."""
        self.show_combat_status()
        self.show_available_actions()
        
        action = self.interface.show_prompt("Wybierz akcję")
        
        if action == "1":  # Atak podstawowy
            damage, special = self.calculate_damage(self.player, self.enemy)
            self.enemy.health -= damage
            message = f"Zadajesz {damage} obrażeń!"
            if special:
                message = f"{special}! {message}"
            self.log_combat_event(message, "success")
            
        elif action == "2":  # Użyj przedmiotu
            self.show_usable_items()
            return False
            
        elif action == "3":  # Ucieczka
            escape_chance = 0.3 + (self.player.level * 0.1)
            if random.random() < escape_chance:
                self.log_combat_event("Udało ci się uciec!", "success")
                return "escaped"
            self.log_combat_event("Nie udało ci się uciec!", "warning")
            
        elif action == "4" and self.player.get_skill_level("walka_mieczem") >= 3:  # Pchnięcie
            success, message = self.use_ability("thrust")
            if success:
                damage, _ = self.calculate_damage(self.player, self.enemy, ability_name="thrust")
                self.enemy.health -= damage
                self.log_combat_event(f"{message} Zadajesz {damage} obrażeń!", "success")
            else:
                self.log_combat_event(message, "error")
                return False
                
        elif action == "5" and self.player.get_skill_level("walka_mieczem") >= 5:  # Wirujący Cios
            success, message = self.use_ability("whirlwind")
            if success:
                damage, _ = self.calculate_damage(self.player, self.enemy, ability_name="whirlwind")
                self.enemy.health -= damage
                self.log_combat_event(f"{message} Zadajesz {damage} obrażeń!", "success")
            else:
                self.log_combat_event(message, "error")
                return False
        
        if self.enemy.health <= 0:
            return "victory"
        return None

    def handle_enemy_turn(self):
        """Obsługuje turę przeciwnika."""
        damage, special = self.calculate_damage(self.enemy, self.player, is_player=False)
        self.player.health -= damage
        
        message = f"{self.enemy.name} zadaje ci {damage} obrażeń!"
        if special:
            message = f"{special}! {message}"
        self.log_combat_event(message, "warning")
        
        if self.player.health <= 0:
            return "defeat"
        return None

    def show_usable_items(self):
        """Wyświetla i obsługuje użycie przedmiotów w walce."""
        usable_items = {}
        print(f"\n{Fore.CYAN}Przedmioty możliwe do użycia:{Style.RESET_ALL}")
        
        for item_id, quantity in self.player.inventory.items.items():
            item = self.player.inventory.item_manager.get_item(item_id)
            if item.type == "konsumpcyjny" and "healing" in item.properties:
                usable_items[item.name.lower()] = item_id
                print(f"- {item.name} x{quantity}")
        
        if not usable_items:
            self.log_combat_event("Nie masz przedmiotów, których możesz użyć!", "warning")
            return False
        
        item_name = input("\nKtórego przedmiotu chcesz użyć? (wpisz 'nic' aby wrócić): ").lower()
        if item_name == "nic":
            return False
            
        if item_name in usable_items:
            success, message = self.player.inventory.use_item(usable_items[item_name], self.player)
            self.log_combat_event(message, "success" if success else "error")
        else:
            self.log_combat_event("Nie ma takiego przedmiotu!", "error")
        return False

    def update_combat_state(self):
        """Aktualizuje stan walki."""
        # Regeneracja staminy
        self.player_stamina = min(100, self.player_stamina + 10)
        
        # Aktualizacja cooldownów
        for ability in list(self.abilities_cooldowns.keys()):
            if self.abilities_cooldowns[ability] > 0:
                self.abilities_cooldowns[ability] -= 1
            if self.abilities_cooldowns[ability] <= 0:
                del self.abilities_cooldowns[ability]

    def start_combat(self):
        """Rozpoczyna i prowadzi walkę."""
        self.log_combat_event(f"Rozpoczyna się walka z {self.enemy.name}!", "system")
        self.log_combat_event(self.enemy.description, "info")
        combat_dialog = CombatDialog(self.interface.root, self)
        combat_dialog.start()
        
        while True:
            # Tura gracza
            result = self.handle_player_turn()
            if result:
                return result
                
            # Tura przeciwnika
            result = self.handle_enemy_turn()
            if result:
                return result
                
            # Aktualizacja stanu walki
            self.update_combat_state()
            self.turn += 1

class CombatDialog(tk.Toplevel):
    """Interfejs walki w trybie GUI."""
    def __init__(self, parent, combat_manager):
        super().__init__(parent)
        self.title("Walka")
        self.combat_manager = combat_manager
        self.create_widgets()
        self.update_combat_status()

    def create_widgets(self):
        """Tworzy widgety interfejsu walki."""
        # Ramka statusu gracza
        self.player_frame = ttk.LabelFrame(self, text="Twój status")
        self.player_frame.pack(fill=tk.X, padx=10, pady=5)

        self.player_hp = ttk.Progressbar(self.player_frame, maximum=self.combat_manager.player.max_health)
        self.player_hp.pack(fill=tk.X, padx=5, pady=5)
        self.player_stamina = ttk.Progressbar(self.player_frame, maximum=100)
        self.player_stamina.pack(fill=tk.X, padx=5, pady=5)

        # Ramka statusu przeciwnika
        self.enemy_frame = ttk.LabelFrame(self, text=f"Przeciwnik: {self.combat_manager.enemy.name}")
        self.enemy_frame.pack(fill=tk.X, padx=10, pady=5)

        self.enemy_hp = ttk.Progressbar(self.enemy_frame, maximum=self.combat_manager.enemy.max_health)
        self.enemy_hp.pack(fill=tk.X, padx=5, pady=5)

        # Ramka akcji
        self.actions_frame = ttk.Frame(self)
        self.actions_frame.pack(fill=tk.X, padx=10, pady=5)

        self.attack_button = ttk.Button(self.actions_frame, text="Atakuj", command=self.player_attack)
        self.attack_button.pack(side=tk.LEFT, padx=5)

        self.ability_button = ttk.Button(self.actions_frame, text="Użyj umiejętności", command=self.use_ability)
        self.ability_button.pack(side=tk.LEFT, padx=5)

        self.item_button = ttk.Button(self.actions_frame, text="Użyj przedmiotu", command=self.use_item)
        self.item_button.pack(side=tk.LEFT, padx=5)

        self.run_button = ttk.Button(self.actions_frame, text="Uciekaj", command=self.attempt_escape)
        self.run_button.pack(side=tk.LEFT, padx=5)

        # Dziennik walki
        self.log = scrolledtext.ScrolledText(self, state='disabled', height=10)
        self.log.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

    def update_combat_status(self):
        """Aktualizuje status gracza i przeciwnika."""
        self.player_hp['value'] = self.combat_manager.player.health
        self.player_hp['maximum'] = self.combat_manager.player.max_health
        self.player_stamina['value'] = self.combat_manager.player_stamina

        self.enemy_hp['value'] = self.combat_manager.enemy.health
        self.enemy_hp['maximum'] = self.combat_manager.enemy.max_health

    def log_event(self, message):
        """Dodaje wpis do dziennika walki."""
        self.log.config(state='normal')
        self.log.insert(tk.END, message + '\n')
        self.log.config(state='disabled')
        self.log.see(tk.END)

    def player_attack(self):
        """Obsługuje atak gracza."""
        self.combat_manager.player_attack()
        self.update_combat_status()
        self.check_combat_end()
        self.enemy_turn()

    def use_ability(self):
        """Pozwala graczowi użyć umiejętności."""
        abilities = ["Pchnięcie", "Wirujący Cios"]
        ability_window = AbilitySelectionDialog(self, abilities)
        self.wait_window(ability_window)
        ability_name = ability_window.selected_ability

        if ability_name:
            success, message = self.combat_manager.use_ability(ability_name.lower())
            self.log_event(message)
            if success:
                damage, special = self.combat_manager.calculate_damage(
                    self.combat_manager.player,
                    self.combat_manager.enemy,
                    ability_name=ability_name.lower()
                )
                self.combat_manager.enemy.health -= damage
                self.log_event(f"Zadajesz {damage} obrażeń! {special}")
                self.update_combat_status()
                self.check_combat_end()
                self.enemy_turn()

    def use_item(self):
        """Pozwala graczowi użyć przedmiotu."""
        # Implementuj wybór przedmiotu do użycia
        pass  # Możesz zaimplementować podobnie jak AbilitySelectionDialog

    def attempt_escape(self):
        """Próbuje ucieczki z walki."""
        if self.combat_manager.attempt_escape():
            self.log_event("Udało ci się uciec!")
            self.destroy()
        else:
            self.log_event("Nie udało ci się uciec!")
            self.enemy_turn()

    def enemy_turn(self):
        """Tura przeciwnika."""
        self.combat_manager.enemy_attack()
        self.update_combat_status()
        self.check_combat_end()

    def check_combat_end(self):
        """Sprawdza, czy walka się zakończyła."""
        if self.combat_manager.player.health <= 0:
            self.log_event("Zostałeś pokonany!")
            self.destroy()
        elif self.combat_manager.enemy.health <= 0:
            self.log_event(f"Pokonałeś {self.combat_manager.enemy.name}!")
            self.destroy()

    def start(self):
        """Rozpoczyna pętlę zdarzeń okna walki."""
        self.mainloop()

class AbilitySelectionDialog(tk.Toplevel):
    """Okno wyboru umiejętności."""
    def __init__(self, parent, abilities):
        super().__init__(parent)
        self.title("Wybierz umiejętność")
        self.selected_ability = None
        self.create_widgets(abilities)

    def create_widgets(self, abilities):
        """Tworzy widgety wyboru umiejętności."""
        label = ttk.Label(self, text="Wybierz umiejętność:")
        label.pack(padx=10, pady=5)

        self.ability_var = tk.StringVar()
        for ability in abilities:
            rb = ttk.Radiobutton(self, text=ability, value=ability, variable=self.ability_var)
            rb.pack(anchor=tk.W, padx=10)

        button = ttk.Button(self, text="OK", command=self.confirm_selection)
        button.pack(pady=10)

    def confirm_selection(self):
        """Potwierdza wybór umiejętności."""
        self.selected_ability = self.ability_var.get()
        self.destroy()

def start_combat_gui(interface, player, enemy):
    """Funkcja uruchamiająca walkę w trybie GUI."""
    combat_manager = CombatManager(player, enemy, interface)
    combat_manager.start_combat_gui()Plik: ./config.py
# config.py
import os
import json
from typing import Dict, Any

class GameConfig:
    """Scentralizowana konfiguracja gry."""
    def __init__(self):
        self.config_dir = 'data'
        self.config: Dict[str, Any] = {
            'game_title': 'Fantasy RPG',
            'version': '1.0.0',
            'window_size': (1200, 800),
            'save_dir': 'saves',
            'data_files': {
                'items': 'items.json',
                'characters': 'characters.json',
                'quests': 'quests.json',
                'skills': 'skills.json',
                'world': 'world.json',
                'dialogues': 'dialogues.json'
            },
            'game_settings': {
                'difficulty': 'normal',
                'auto_save': True,
                'auto_save_interval': 300,  # w sekundach
                'music_volume': 0.7,
                'sfx_volume': 1.0,
                'fullscreen': False,
                'language': 'pl'
            },
            'gameplay': {
                'starting_location': 'miasto_startowe',
                'starting_gold': 100,
                'starting_health': 100,
                'exp_multiplier': 1.0,
                'loot_multiplier': 1.0,
                'combat': {
                    'crit_chance_base': 0.15,
                    'dodge_chance_base': 0.10,
                    'defense_bonus_base': 5
                }
            },
            'gui': {
                'theme': 'dark',
                'colors': {
                    'bg_dark': '#1E1E1E',
                    'bg_medium': '#2D2D2D',
                    'text_light': '#E0E0E0',
                    'accent': '#17a2b8',
                    'success': '#28a745',
                    'warning': '#ffc107',
                    'error': '#dc3545',
                    'health': '#dc3545',
                    'mana': '#007bff',
                    'exp': '#17a2b8'
                },
                'fonts': {
                    'main': ('Segoe UI', 10),
                    'header': ('Segoe UI', 12, 'bold'),
                    'monospace': ('Consolas', 11)
                }
            }
        }
        self.load_config()

    def load_config(self):
        """Ładuje konfigurację z pliku."""
        config_path = os.path.join(self.config_dir, 'config.json')
        if os.path.exists(config_path):
            try:
                with open(config_path, 'r', encoding='utf-8') as f:
                    loaded_config = json.load(f)
                    self.config.update(loaded_config)
            except Exception as e:
                print(f"Błąd podczas ładowania konfiguracji: {e}")

    def save_config(self):
        """Zapisuje konfigurację do pliku."""
        config_path = os.path.join(self.config_dir, 'config.json')
        try:
            os.makedirs(self.config_dir, exist_ok=True)
            with open(config_path, 'w', encoding='utf-8') as f:
                json.dump(self.config, f, indent=4, ensure_ascii=False)
        except Exception as e:
            print(f"Błąd podczas zapisywania konfiguracji: {e}")

    def get(self, key: str, default: Any = None) -> Any:
        """Pobiera wartość z konfiguracji."""
        keys = key.split('.')
        value = self.config
        for k in keys:
            if isinstance(value, dict):
                value = value.get(k)
            else:
                return default
        return value if value is not None else default

    def set(self, key: str, value: Any) -> None:
        """Ustawia wartość w konfiguracji."""
        keys = key.split('.')
        config = self.config
        for k in keys[:-1]:
            if k not in config:
                config[k] = {}
            config = config[k]
        config[keys[-1]] = value
        self.save_config()

# Singleton konfiguracji
game_config = GameConfig()Plik: ./data/characters.json
{
    "characters": {
      "kupiec_jan": {
        "name": "Kupiec Jan",
        "description": "Przyjazny kupiec sprzedający podstawowe towary.",
        "location": "miasto_startowe",
        "dialogues": ["Witaj, podróżniku! Czy chcesz coś kupić?"],
        "inventory": ["mikstura_zdrowia", "chleb", "miecz_zardzewiały", "tarcza_drewniana"],
        "prices": {
            "miecz_zardzewiały": 100,
            "tarcza_drewniana": 80,
            "mikstura_zdrowia": 50,
            "chleb": 10
        }
      },
      "strażnik_piotr": {
        "name": "Strażnik Piotr",
        "description": "Czujny strażnik pilnujący porządku w mieście.",
        "location": "miasto_startowe",
        "dialogues": ["Uważaj na niebezpieczeństwa poza murami miasta."],
        "inventory": []
      },
      "tajemniczy_starzec": {
        "name": "Tajemniczy Starzec",
        "description": "Stary mężczyzna o przenikliwym spojrzeniu.",
        "location": "las_cieni",
        "dialogues": ["Nie wszystko jest takie, jakim się wydaje..."],
        "inventory": ["klucz_do_jaskini"]
      },
      "goblin": {
            "name": "Goblin",
            "description": "Małe, złośliwe stworzenie.",
            "location": "jaskinia",
            "dialogues": ["Grrrr!"],
            "is_enemy": true,
            "health": 30,
            "strength": 8,
            "defense": 3,
            "exp": 25,
            "inventory": ["złota_monetka"],
            "loot_table": {
                "mikstura_zdrowia": 0.3,
                "złota_monetka": 0.8
            }
        },
        "wilk": {
            "name": "Dziki Wilk",
            "description": "Groźny wilk z lasu.",
            "location": "las_cieni",
            "is_enemy": true,
            "health": 40,
            "strength": 12,
            "defense": 2,
            "exp": 35,
            "inventory": [],
            "loot_table": {
                "skóra_wilka": 0.9,
                "kieł_wilka": 0.4
            }
        }
    }
}Plik: ./data/dialogues.json
Plik: ./data/items.json
{
    "items": {
      "miecz_zardzewiały": {
        "name": "Zardzewiały Miecz",
        "description": "Stary miecz, który nadal może się przydać.",
        "type": "broń",
        "damage": 5
      },
      "tarcza_drewniana": {
        "name": "Drewniana Tarcza",
        "description": "Prosta tarcza wykonana z drewna.",
        "type": "zbroja",
        "defense": 2
      },
      "mikstura_zdrowia": {
        "name": "Mikstura Zdrowia",
        "description": "Przywraca 20 punktów zdrowia.",
        "type": "konsumpcyjny",
        "healing": 20
      },
      "klucz_do_jaskini": {
        "name": "Klucz do Jaskini",
        "description": "Klucz otwierający drzwi w jaskini.",
        "type": "klucz"
      },
      "złota_monetka": {
        "name": "Złota Monetka",
        "description": "Błyszcząca złota moneta.",
        "type": "waluta",
        "value": 10
      },
      "zioła_uzdrawiające": {
        "name": "Zioła Uzdrawiające",
        "description": "Mogą posłużyć do stworzenia mikstury zdrowia.",
        "type": "surowiec"
      },
      "chleb": { 
        "name": "Chleb",
        "description": "Świeży, pachnący chleb.",
        "type": "jedzenie",
        "healing": 10
      }
    }
}Plik: ./data/quests.json
{
    "quests": {
        "dostawa_towarow": {
            "name": "Dostawa towarów",
            "giver": "kupiec_jan",
            "description": "Kupiec Jan potrzebuje dostarczyć towary do sąsiedniego miasta, ale droga jest niebezpieczna.",
            "type": "delivery",
            "difficulty": "easy",
            "min_level": 1,
            "stages": [
                {
                    "id": 1,
                    "description": "Odbierz towary od Kupca Jana",
                    "objective": "talk_to",
                    "target": "kupiec_jan",
                    "dialog": "Potrzebuję kogoś, kto dostarczy te towary do miasta. Zapłacę 100 sztuk złota."
                },
                {
                    "id": 2,
                    "description": "Dostarcz towary do miasta",
                    "objective": "go_to",
                    "target": "trakt_kupiecki",
                    "optional": {
                        "combat": "bandyta_prosty",
                        "reward_bonus": 50
                    }
                }
            ],
            "rewards": {
                "gold": 100,
                "exp": 50,
                "items": ["mikstura_zdrowia"],
                "reputation": {
                    "gildia_kupcow": 10
                }
            },
            "failure_penalties": {
                "reputation": {
                    "gildia_kupcow": -5
                }
            }
        },
        "polowanie_na_wilki": {
            "name": "Problem z wilkami",
            "giver": "mysliwy_borys",
            "description": "Stado wilków terroryzuje okoliczne wioski. Myśliwy Borys prosi o pomoc w ich wytropieniu.",
            "type": "hunting",
            "difficulty": "medium",
            "min_level": 2,
            "prerequisites": {
                "reputation": {
                    "mysliwi": 0
                }
            },
            "stages": [
                {
                    "id": 1,
                    "description": "Porozmawiaj z Myśliwym Borysem o wilkach",
                    "objective": "talk_to",
                    "target": "mysliwy_borys"
                },
                {
                    "id": 2,
                    "description": "Znajdź ślady wilków w Lesie Cieni",
                    "objective": "investigate",
                    "target": "las_cieni",
                    "required_items": ["trop_wilka"]
                },
                {
                    "id": 3,
                    "description": "Pokonaj alfę stada",
                    "objective": "kill",
                    "target": "wilk_alfa",
                    "count": 1
                }
            ],
            "rewards": {
                "gold": 200,
                "exp": 150,
                "items": ["skora_wilka_alfy", "kiel_wilka"],
                "reputation": {
                    "mysliwi": 20,
                    "krag_druidow": -5
                }
            }
        },
        "zaginiony_amulet": {
            "name": "Zaginiony amulet",
            "giver": "tajemniczy_starzec",
            "description": "Tajemniczy starzec twierdzi, że w jaskini znajduje się starożytny amulet o wielkiej mocy.",
            "type": "exploration",
            "difficulty": "hard",
            "min_level": 3,
            "time_limit": "7 days",
            "stages": [
                {
                    "id": 1,
                    "description": "Znajdź wejście do starożytnej części jaskini",
                    "objective": "explore",
                    "target": "jaskinia",
                    "required_items": ["stara_mapa"]
                },
                {
                    "id": 2,
                    "description": "Pokonaj strażnika amulet",
                    "objective": "kill",
                    "target": "goblin_szaman",
                    "count": 1
                },
                {
                    "id": 3,
                    "description": "Zdobądź amulet",
                    "objective": "collect",
                    "target": "pradawny_amulet"
                },
                {
                    "id": 4,
                    "description": "Wróć do Tajemniczego Starca",
                    "objective": "talk_to",
                    "target": "tajemniczy_starzec",
                    "choices": [
                        {
                            "text": "Oddaj amulet",
                            "rewards": {
                                "gold": 500,
                                "exp": 300,
                                "reputation": {
                                    "krag_druidow": 30
                                }
                            }
                        },
                        {
                            "text": "Zachowaj amulet",
                            "rewards": {
                                "items": ["pradawny_amulet"],
                                "reputation": {
                                    "krag_druidow": -20
                                }
                            }
                        }
                    ]
                }
            ],
            "rewards": {
                "exp": 200,
                "unlock_quest": "tajemnice_pradawnych"
            }
        },
        "zielarka_potrzebuje_pomocy": {
            "name": "Zioła dla Zielarki",
            "giver": "zielarka_anna",
            "description": "Zielarka Anna potrzebuje rzadkich ziół do swoich mikstur.",
            "type": "gathering",
            "difficulty": "easy",
            "min_level": 1,
            "repeatable": true,
            "cooldown": "1 day",
            "stages": [
                {
                    "id": 1,
                    "description": "Zbierz zioła w Lesie Cieni",
                    "objective": "gather",
                    "target": "ziola_rzadkie",
                    "count": 5
                }
            ],
            "rewards": {
                "gold": 50,
                "exp": 30,
                "items": ["mikstura_zdrowia"],
                "reputation": {
                    "zielarze": 5
                }
            }
        }
    },
    "quest_types": {
        "delivery": {
            "name": "Dostawa",
            "description": "Questy polegające na dostarczeniu przedmiotów"
        },
        "hunting": {
            "name": "Polowanie",
            "description": "Questy polegające na polowaniu na potwory"
        },
        "exploration": {
            "name": "Eksploracja",
            "description": "Questy polegające na odkrywaniu nowych miejsc"
        },
        "gathering": {
            "name": "Zbieranie",
            "description": "Questy polegające na zbieraniu surowców"
        }
    }
}Plik: ./data/skills.json
{
    "skills": {
        "combat": {
            "walka_mieczem": {
                "name": "Walka mieczem",
                "description": "Umiejętność władania mieczem",
                "max_level": 5,
                "levels": {
                    "1": {
                        "description": "Podstawy walki mieczem",
                        "damage_bonus": 2,
                        "required_exp": 0
                    },
                    "2": {
                        "description": "Blokowanie ciosów",
                        "damage_bonus": 4,
                        "defense_bonus": 1,
                        "required_exp": 100
                    },
                    "3": {
                        "description": "Pchnięcie",
                        "damage_bonus": 6,
                        "special_attack": "thrust",
                        "required_exp": 300
                    },
                    "4": {
                        "description": "Mistrzostwo obrony",
                        "damage_bonus": 8,
                        "defense_bonus": 2,
                        "required_exp": 600
                    },
                    "5": {
                        "description": "Wirujący cios",
                        "damage_bonus": 10,
                        "special_attack": "whirlwind",
                        "required_exp": 1000
                    }
                }
            },
            "lucznictwo": {
                "name": "Łucznictwo",
                "description": "Umiejętność strzelania z łuku",
                "max_level": 5,
                "levels": {
                    "1": {
                        "description": "Podstawy łucznictwa",
                        "damage_bonus": 2,
                        "required_exp": 0
                    },
                    "2": {
                        "description": "Celny strzał",
                        "damage_bonus": 4,
                        "accuracy_bonus": 10,
                        "required_exp": 100
                    }
                }
            }
        },
        "crafting": {
            "kowalstwo": {
                "name": "Kowalstwo",
                "description": "Umiejętność wytwarzania broni i pancerzy",
                "max_level": 5,
                "levels": {
                    "1": {
                        "description": "Podstawy kowalstwa",
                        "recipes": ["miecz_zelazny", "tarcza_zelazna"],
                        "required_exp": 0
                    },
                    "2": {
                        "description": "Ulepszanie broni",
                        "recipes": ["miecz_stalowy"],
                        "special_ability": "weapon_improvement",
                        "required_exp": 150
                    }
                }
            },
            "zielarstwo": {
                "name": "Zielarstwo",
                "description": "Umiejętność zbierania i przetwarzania ziół",
                "max_level": 5,
                "levels": {
                    "1": {
                        "description": "Podstawy zielarstwa",
                        "recipes": ["mikstura_zdrowia_mala"],
                        "gathering_bonus": 10,
                        "required_exp": 0
                    },
                    "2": {
                        "description": "Zaawansowane mikstury",
                        "recipes": ["mikstura_zdrowia_srednia", "mikstura_many"],
                        "gathering_bonus": 20,
                        "required_exp": 200
                    }
                }
            }
        },
        "survival": {
            "tropienie": {
                "name": "Tropienie",
                "description": "Umiejętność śledzenia i znajdowania stworzeń",
                "max_level": 3,
                "levels": {
                    "1": {
                        "description": "Podstawy tropienia",
                        "detection_range": 10,
                        "required_exp": 0
                    },
                    "2": {
                        "description": "Zaawansowane tropienie",
                        "detection_range": 20,
                        "special_ability": "track_rare_creatures",
                        "required_exp": 250
                    }
                }
            }
        }
    },
    "special_abilities": {
        "thrust": {
            "name": "Pchnięcie",
            "description": "Silny atak zadający podwójne obrażenia",
            "damage_multiplier": 2.0,
            "stamina_cost": 30,
            "cooldown": 10
        },
        "whirlwind": {
            "name": "Wirujący cios",
            "description": "Atak obszarowy trafiający wszystkich przeciwników w zasięgu",
            "damage_multiplier": 1.5,
            "range": 2,
            "stamina_cost": 50,
            "cooldown": 30
        },
        "weapon_improvement": {
            "name": "Ulepszanie broni",
            "description": "Możliwość ulepszania broni o +1 do obrażeń",
            "cost": {
                "gold": 100,
                "materials": ["ruda_zelaza"]
            }
        },
        "track_rare_creatures": {
            "name": "Tropienie rzadkich stworzeń",
            "description": "Możliwość znajdowania rzadkich stworzeń",
            "success_chance": 0.25,
            "cooldown": 3600
        }
    }
}Plik: ./data/world.json
{
  "world": {
    "locations": {
      "miasto_startowe": {
        "name": "Miasto Startowe",
        "description": "Małe, spokojne miasteczko, w którym zaczynasz swoją przygodę.",
        "npcs": ["kupiec_jan", "strażnik_piotr"],
        "items": ["miecz_zardzewiały", "tarcza_drewniana"],
        "exits": ["las_cieni"],
        "events": []
      },
      "las_cieni": {
        "name": "Las Cieni",
        "description": "Gęsty i tajemniczy las, pełen nieznanych stworzeń.",
        "npcs": ["tajemniczy_starzec"],
        "items": ["zioła_uzdrawiające"],
        "exits": ["miasto_startowe", "jaskinia"],
        "events": []
      },
      "jaskinia": {
        "name": "Jaskinia",
        "description": "Mroczna jaskinia, z której słychać dziwne odgłosy.",
        "npcs": ["goblin"],
        "items": ["złota_monetka"],
        "exits": ["las_cieni"],
        "events": []
      }
    },
    "connections": [
      {
        "from": "miasto_startowe",
        "to": "las_cieni",
        "description": "Ścieżka prowadząca do Lasu Cieni."
      },
      {
        "from": "las_cieni",
        "to": "jaskinia",
        "description": "Ukryte przejście do Jaskini."
      },
      {
        "from": "jaskinia",
        "to": "las_cieni",
        "description": "Wyjście z Jaskini do Lasu Cieni."
      },
      {
        "from": "las_cieni",
        "to": "miasto_startowe",
        "description": "Ścieżka prowadząca z powrotem do Miasta Startowego."
      }
    ]
  }
}
Plik: ./dialogue.py
# dialog.py

class DialogManager:
    def __init__(self, interface):
        self.interface = interface
        self.current_dialog = None
        self.dialog_history = []

    def start_dialog(self, npc, player):
        """Rozpoczyna dialog z NPC."""
        dialog = Dialog(npc, player, self.interface)
        self.current_dialog = dialog
        return dialog.start()

class Dialog:
    def __init__(self, npc, player, interface):
        self.npc = npc
        self.player = player
        self.interface = interface
        self.dialog_options = []
        self.quest_options = []

    def start(self):
        """Rozpoczyna dialog i zwraca pierwsze opcje."""
        # Przywitanie
        self.interface.show_message(f"\n{self.npc.name}: {random.choice(self.npc.dialogues)}", "dialog")
        
        # Przygotuj opcje dialogowe
        self.prepare_dialog_options()
        
        # Pokaż dostępne opcje
        self.show_options()

    def prepare_dialog_options(self):
        """Przygotowuje dostępne opcje dialogowe."""
        self.dialog_options = []
        
        # Podstawowe opcje
        self.dialog_options.append(("Jak się masz?", self.general_chat))
        
        # Opcje handlu jeśli NPC jest kupcem
        if isinstance(self.npc, Merchant):
            self.dialog_options.append(("Pokaż mi swoje towary", self.start_trade))
        
        # Opcje questów
        available_quests = [quest for quest in self.player.quest_manager.get_available_quests(self.player, self.npc.id)
                          if quest.giver == self.npc.id]
        if available_quests:
            self.quest_options = available_quests
            self.dialog_options.append(("Masz jakieś zadania?", self.show_quests))
        
        # Opcja zakończenia
        self.dialog_options.append(("Do widzenia", self.end_dialog))

    def show_options(self):
        """Wyświetla dostępne opcje dialogowe."""
        self.interface.show_message("\nDostępne opcje:", "system")
        for i, (option, _) in enumerate(self.dialog_options, 1):
            self.interface.show_message(f"{i}. {option}", "dialog")

    def handle_choice(self, choice):
        """Obsługuje wybór opcji przez gracza."""
        try:
            choice = int(choice)
            if 1 <= choice <= len(self.dialog_options):
                option, handler = self.dialog_options[choice - 1]
                handler()
            else:
                self.interface.show_message("Nieprawidłowy wybór.", "error")
        except ValueError:
            self.interface.show_message("Wprowadź numer opcji.", "error")

    def general_chat(self):
        """Obsługuje ogólną rozmowę."""
        response = random.choice([
            "Wszystko w porządku, dziękuję za pytanie.",
            "Bywało lepiej, ale nie narzekam.",
            "Interesujące czasy nastały...",
            "Mam sporo pracy ostatnio."
        ])
        self.interface.show_message(f"\n{self.npc.name}: {response}", "dialog")
        self.show_options()

    def start_trade(self):
        """Rozpoczyna handel z kupcem."""
        if isinstance(self.npc, Merchant):
            self.interface.show_trade_menu(self.npc, self.player)
        self.show_options()

    def show_quests(self):
        """Pokazuje dostępne questy."""
        if self.quest_options:
            self.interface.show_message("\nDostępne zadania:", "quest")
            for i, quest in enumerate(self.quest_options, 1):
                self.interface.show_message(f"{i}. {quest.name} - {quest.description}", "quest")
                
            self.interface.show_message("\nWprowadź numer zadania, które chcesz przyjąć (0 aby wrócić):", "system")
            return "quest_selection"
        else:
            self.interface.show_message(f"\n{self.npc.name}: Nie mam obecnie żadnych zadań dla ciebie.", "dialog")
            self.show_options()

    def handle_quest_selection(self, choice):
        """Obsługuje wybór questa przez gracza."""
        try:
            choice = int(choice)
            if choice == 0:
                self.show_options()
                return
                
            if 1 <= choice <= len(self.quest_options):
                quest = self.quest_options[choice - 1]
                success, message = self.player.quest_manager.start_quest(quest.id, self.player)
                self.interface.show_message(message, "quest" if success else "error")
            else:
                self.interface.show_message("Nieprawidłowy wybór.", "error")
        except ValueError:
            self.interface.show_message("Wprowadź numer zadania.", "error")
        
        self.show_options()

    def end_dialog(self):
        """Kończy dialog."""
        self.interface.show_message(f"\n{self.npc.name}: Do zobaczenia!", "dialog")
        return "end"

class DialogGUI(tk.Toplevel):
    def __init__(self, parent, npc, player):
        super().__init__(parent)
        self.title(f"Rozmowa z {npc.name}")
        self.npc = npc
        self.player = player
        self.setup_gui()
        
    def setup_gui(self):
        """Konfiguruje interfejs okna dialogowego."""
        # Obszar dialogu
        self.dialog_text = scrolledtext.ScrolledText(
            self,
            wrap=tk.WORD,
            width=60,
            height=20,
            bg='#1E1E1E',
            fg='#E0E0E0',
            font=('Segoe UI', 10)
        )
        self.dialog_text.pack(padx=10, pady=5, fill=tk.BOTH, expand=True)
        
        # Panel opcji
        self.options_frame = ttk.Frame(self, style='Modern.TFrame')
        self.options_frame.pack(fill=tk.X, padx=10, pady=5)
        
        # Przyciski opcji
        self.option_buttons = []
        
    def add_text(self, text, tag=None):
        """Dodaje tekst do okna dialogowego."""
        self.dialog_text.config(state='normal')
        self.dialog_text.insert(tk.END, text + '\n', tag)
        self.dialog_text.config(state='disabled')
        self.dialog_text.see(tk.END)
        
    def update_options(self, options):
        """Aktualizuje dostępne opcje dialogowe."""
        # Usuń stare przyciski
        for button in self.option_buttons:
            button.destroy()
        self.option_buttons.clear()
        
        # Dodaj nowe przyciski
        for text, handler in options:
            btn = ttk.Button(
                self.options_frame,
                text=text,
                style='Modern.TButton',
                command=handler
            )
            btn.pack(fill=tk.X, pady=2)
            self.option_buttons.append(btn)Plik: ./entities.py
# entities.py
from typing import Dict, List, Optional, Union, Any, Tuple
from dataclasses import dataclass
from abc import ABC, abstractmethod
import random
import logging
import time
import math
from config import game_config
from exceptions import (
    GameError, RequirementsNotMetError, 
    InsufficientFundsError, InvalidSkillError
)

logger = logging.getLogger(__name__)

@dataclass
class Position:
    """Reprezentacja pozycji w świecie gry."""
    x: float
    y: float
    z: float = 0.0

    def distance_to(self, other: 'Position') -> float:
        """Oblicza odległość do innej pozycji."""
        return math.sqrt(
            (self.x - other.x) ** 2 + 
            (self.y - other.y) ** 2 + 
            (self.z - other.z) ** 2
        )

@dataclass
class Stats:
    """Podstawowe statystyki jednostki."""
    health: int = 100
    max_health: int = 100
    stamina: int = 100
    max_stamina: int = 100
    mana: int = 0
    max_mana: int = 0
    strength: int = 10
    defense: int = 5
    agility: int = 10
    intelligence: int = 10
    critical_chance: float = 0.05
    dodge_chance: float = 0.05
    
    def modify_stat(self, stat_name: str, value: float, is_percentage: bool = False):
        """Modyfikuje wartość statystyki."""
        if hasattr(self, stat_name):
            current_value = getattr(self, stat_name)
            if is_percentage:
                new_value = current_value * (1 + value)
            else:
                new_value = current_value + value
                
            # Upewnij się, że wartości nie spadną poniżej 0
            if stat_name.startswith('max_'):
                new_value = max(1, new_value)
            else:
                max_stat = getattr(self, f"max_{stat_name}", float('inf'))
                new_value = min(max(0, new_value), max_stat)
                
            setattr(self, stat_name, new_value)

@dataclass
class StatusEffect:
    """Efekt statusu wpływający na jednostkę."""
    name: str
    type: str  # buff, debuff, dot, hot
    stat_modifiers: Dict[str, float]
    duration: int
    tick_interval: int = 1
    last_tick: float = 0.0
    description: str = ""
    is_permanent: bool = False
    can_stack: bool = False
    icon: str = ""
    
    def apply(self, target: 'Entity'):
        """Aplikuje efekt na cel."""
        for stat, modifier in self.stat_modifiers.items():
            target.stats.modify_stat(stat, modifier, is_percentage=True)

    def remove(self, target: 'Entity'):
        """Usuwa efekt z celu."""
        for stat, modifier in self.stat_modifiers.items():
            target.stats.modify_stat(stat, -modifier, is_percentage=True)

class CombatStats:
    """Statystyki związane z walką."""
    def __init__(self):
        self.damage_dealt: float = 0
        self.damage_taken: float = 0
        self.healing_done: float = 0
        self.critical_hits: int = 0
        self.dodges: int = 0
        self.kills: int = 0
        self.deaths: int = 0
        self.longest_combat: float = 0
        self.highest_damage: float = 0
        self.highest_combo: int = 0
        
    def update_damage_stats(self, damage: float, is_critical: bool = False):
        """Aktualizuje statystyki obrażeń."""
        self.damage_dealt += damage
        if damage > self.highest_damage:
            self.highest_damage = damage
        if is_critical:
            self.critical_hits += 1

class Entity(ABC):
    """Bazowa klasa dla wszystkich jednostek w grze."""
    
    def __init__(self, entity_id: str, data: dict):
        self.id = entity_id
        self.name = data.get('name', 'Unknown Entity')
        self.description = data.get('description', '')
        self.level = data.get('level', 1)
        
        # Podstawowe statystyki
        stats_data = data.get('stats', {})
        self.stats = Stats(**stats_data)
        
        # Pozycja w świecie
        position_data = data.get('position', {'x': 0, 'y': 0, 'z': 0})
        self.position = Position(**position_data)
        
        # Status i efekty
        self.status_effects: List[StatusEffect] = []
        self.is_alive = True
        self.is_stunned = False
        self.is_invisible = False
        
        # Atrybuty walki
        self.in_combat = False
        self.last_attack_time = 0.0
        self.attack_cooldown = data.get('attack_cooldown', 1.0)
        self.combat_stats = CombatStats()
        
        # Ekwipunek i zasoby
        self.inventory = None  # Będzie zainicjalizowane przez initialize_inventory
        self.gold = data.get('gold', 0)
        
        # Umiejętności i zdolności
        self.abilities = {}
        self.resistances = data.get('resistances', {})
        self.skill_bonuses = {}
        self._load_abilities(data.get('abilities', {}))
        
    # Kontynuacja klasy Entity

    def initialize_inventory(self, item_manager):
        """Inicjalizuje ekwipunek jednostki."""
        from inventory import Inventory  # Import na poziomie metody aby uniknąć circular import
        self.inventory = Inventory()
        self.inventory.set_item_manager(item_manager)

    def _load_abilities(self, abilities_data: dict):
        """Ładuje zdolności jednostki."""
        for ability_id, ability_data in abilities_data.items():
            self.abilities[ability_id] = {
                'name': ability_data['name'],
                'damage': ability_data.get('damage', 0),
                'cooldown': ability_data.get('cooldown', 0),
                'cost': ability_data.get('cost', 0),
                'effects': ability_data.get('effects', []),
                'requirements': ability_data.get('requirements', {}),
                'range': ability_data.get('range', 1.0),
                'area_of_effect': ability_data.get('area_of_effect', 0),
                'cast_time': ability_data.get('cast_time', 0),
                'description': ability_data.get('description', '')
            }

    @property
    def current_stats(self) -> Stats:
        """Zwraca aktualne statystyki z uwzględnieniem efektów statusu."""
        modified_stats = Stats(
            health=self.stats.health,
            max_health=self.stats.max_health,
            stamina=self.stats.stamina,
            max_stamina=self.stats.max_stamina,
            mana=self.stats.mana,
            max_mana=self.stats.max_mana,
            strength=self.stats.strength,
            defense=self.stats.defense,
            agility=self.stats.agility,
            intelligence=self.stats.intelligence,
            critical_chance=self.stats.critical_chance,
            dodge_chance=self.stats.dodge_chance
        )
        
        # Aplikowanie modyfikatorów z efektów statusu
        for effect in self.status_effects:
            for stat, modifier in effect.stat_modifiers.items():
                current_value = getattr(modified_stats, stat, 0)
                modified_value = current_value * (1 + modifier)
                setattr(modified_stats, stat, modified_value)
        
        # Aplikowanie modyfikatorów z ekwipunku
        if self.inventory:
            equipment_modifiers = self.inventory.get_equipment_modifiers()
            for stat, modifier in equipment_modifiers.items():
                if hasattr(modified_stats, stat):
                    current_value = getattr(modified_stats, stat)
                    modified_value = current_value + modifier
                    setattr(modified_stats, stat, modified_value)
        
        return modified_stats

    def update(self, game_time: float):
        """Aktualizuje stan jednostki."""
        # Aktualizacja efektów statusu
        self._update_status_effects(game_time)
        
        # Regeneracja zasobów
        self._update_resources()
        
        # Sprawdzenie stanu życia
        if self.stats.health <= 0 and self.is_alive:
            self.die()
        
        # Aktualizacja cooldownów
        self._update_cooldowns(game_time)
        
        # Aktualizacja stanu walki
        if self.in_combat:
            self.update_combat(game_time)

    def update_combat(self, game_time: float) -> bool:
        """Aktualizuje stan jednostki w walce."""
        # Aktualizacja cooldownów
        if self.last_attack_time + self.attack_cooldown > game_time:
            return False
            
        self.last_attack_time = game_time
        return True

    def _update_status_effects(self, game_time: float):
        """Aktualizuje efekty statusu."""
        active_effects = []
        for effect in self.status_effects:
            if effect.is_permanent or effect.duration > 0:
                if not effect.is_permanent:
                    effect.duration -= 1
                
                if game_time - effect.last_tick >= effect.tick_interval:
                    self._apply_effect_tick(effect)
                    effect.last_tick = game_time
                    
                active_effects.append(effect)
            else:
                effect.remove(self)
                
        self.status_effects = active_effects

    def _update_resources(self):
        """Aktualizuje zasoby jednostki (stamina, mana, itp.)."""
        stats = self.stats
        regen_modifiers = self.get_regeneration_modifiers()
        
        # Regeneracja staminy
        if stats.stamina < stats.max_stamina:
            regen_amount = 5 * regen_modifiers.get('stamina', 1.0)
            stats.stamina = min(stats.max_stamina, stats.stamina + regen_amount)
            
        # Regeneracja many
        if stats.mana < stats.max_mana:
            regen_amount = 2 * regen_modifiers.get('mana', 1.0)
            stats.mana = min(stats.max_mana, stats.mana + regen_amount)

    def get_regeneration_modifiers(self) -> Dict[str, float]:
        """Zwraca modyfikatory regeneracji zasobów."""
        modifiers = {
            'health': 1.0,
            'stamina': 1.0,
            'mana': 1.0
        }
        
        # Modyfikatory z efektów statusu
        for effect in self.status_effects:
            if 'regeneration' in effect.stat_modifiers:
                resource = effect.stat_modifiers['regeneration']['resource']
                value = effect.stat_modifiers['regeneration']['value']
                modifiers[resource] *= (1 + value)
                
        # Modyfikatory z ekwipunku
        if self.inventory:
            equipment_regen = self.inventory.get_regeneration_modifiers()
            for resource, value in equipment_regen.items():
                modifiers[resource] *= (1 + value)
                
        return modifiers

    def _apply_effect_tick(self, effect: StatusEffect):
        """Aplikuje pojedynczy tick efektu statusu."""
        if effect.type == 'dot':  # Damage over time
            damage = sum(effect.stat_modifiers.values())
            self.take_damage(damage, 'magical')
        elif effect.type == 'hot':  # Healing over time
            healing = sum(effect.stat_modifiers.values())
            self.heal(healing)
        elif effect.type == 'resource_regen':  # Regeneracja zasobów
            for resource, value in effect.stat_modifiers.items():
                if hasattr(self.stats, resource):
                    current = getattr(self.stats, resource)
                    max_value = getattr(self.stats, f'max_{resource}')
                    new_value = min(max_value, current + value)
                    setattr(self.stats, resource, new_value)

    def _remove_effect(self, effect: StatusEffect):
        """Usuwa efekt statusu."""
        try:
            effect.remove(self)
            self.status_effects.remove(effect)
        except ValueError:
            pass

    def add_status_effect(self, effect: StatusEffect):
        """Dodaje efekt statusu."""
        # Sprawdź czy podobny efekt już istnieje
        for existing_effect in self.status_effects:
            if existing_effect.name == effect.name:
                if not effect.can_stack:
                    # Odśwież czas trwania jeśli nowy efekt jest silniejszy
                    if sum(effect.stat_modifiers.values()) > sum(existing_effect.stat_modifiers.values()):
                        existing_effect.remove(self)
                        self.status_effects.remove(existing_effect)
                        effect.apply(self)
                        self.status_effects.append(effect)
                    else:
                        existing_effect.duration = max(existing_effect.duration, effect.duration)
                    return
                
        effect.apply(self)
        self.status_effects.append(effect)
        
    # Kontynuacja klasy Entity
    
    def take_damage(self, damage: float, damage_type: str = 'physical') -> Tuple[float, bool, bool]:
        """Przyjmuje obrażenia z uwzględnieniem odporności.
        
        Returns:
            Tuple[float, bool, bool]: (otrzymane_obrażenia, czy_unik, czy_krytyczne)
        """
        if not self.is_alive:
            return 0, False, False

        # Sprawdź unik
        if self._try_dodge():
            self.combat_stats.dodges += 1
            return 0, True, False

        # Oblicz rzeczywiste obrażenia
        actual_damage = self._calculate_damage(damage, damage_type)
        
        # Aplikuj obrażenia
        self.stats.health = max(0, self.stats.health - actual_damage)
        self.combat_stats.damage_taken += actual_damage
        
        # Sprawdź stan życia
        if self.stats.health <= 0:
            self.die()
            
        logger.debug(
            f"{self.name} otrzymał {actual_damage:.1f} obrażeń typu {damage_type} "
            f"(Pozostałe HP: {self.stats.health:.1f}/{self.stats.max_health})"
        )
        
        return actual_damage, False, False

    def _try_dodge(self) -> bool:
        """Próba uniku ataku."""
        dodge_chance = self.current_stats.dodge_chance
        
        # Modyfikatory z efektów statusu
        for effect in self.status_effects:
            if 'dodge_bonus' in effect.stat_modifiers:
                dodge_chance += effect.stat_modifiers['dodge_bonus']
        
        # Nie można mieć więcej niż 75% szansy na unik
        dodge_chance = min(0.75, dodge_chance)
        
        return random.random() < dodge_chance

    def _calculate_damage(self, base_damage: float, damage_type: str) -> float:
        """Oblicza rzeczywiste obrażenia po uwzględnieniu wszystkich modyfikatorów."""
        # Podstawowa redukcja obrażeń z odporności
        resistance = self.resistances.get(damage_type, 0)
        damage = base_damage * (1 - resistance)
        
        # Modyfikatory z efektów statusu
        for effect in self.status_effects:
            if 'damage_taken_modifier' in effect.stat_modifiers:
                damage *= (1 + effect.stat_modifiers['damage_taken_modifier'])
        
        # Uwzględnij obronę
        defense_reduction = self.current_stats.defense / (self.current_stats.defense + 100)
        damage *= (1 - defense_reduction)
        
        # Zaokrąglij do jednego miejsca po przecinku
        return round(max(0, damage), 1)

    def deal_damage(self, target: 'Entity', base_damage: float, 
                   damage_type: str = 'physical') -> Tuple[float, bool, bool]:
        """Zadaje obrażenia celowi.
        
        Returns:
            Tuple[float, bool, bool]: (zadane_obrażenia, czy_unik, czy_krytyczne)
        """
        if not target.is_alive or not self.is_alive:
            return 0, False, False
            
        # Sprawdź czy atak jest krytyczny
        is_critical = self._is_critical_hit()
        if is_critical:
            base_damage *= self._get_critical_multiplier()
            self.combat_stats.critical_hits += 1
            
        # Aplikuj modyfikatory obrażeń atakującego
        damage = self._modify_outgoing_damage(base_damage, damage_type)
        
        # Zadaj obrażenia celowi
        actual_damage, was_dodged, _ = target.take_damage(damage, damage_type)
        
        # Aktualizuj statystyki walki
        self.combat_stats.update_damage_stats(actual_damage, is_critical)
        
        return actual_damage, was_dodged, is_critical

    def _is_critical_hit(self) -> bool:
        """Sprawdza czy atak jest krytyczny."""
        crit_chance = self.current_stats.critical_chance
        
        # Modyfikatory z efektów statusu
        for effect in self.status_effects:
            if 'crit_chance_bonus' in effect.stat_modifiers:
                crit_chance += effect.stat_modifiers['crit_chance_bonus']
        
        # Nie można mieć więcej niż 75% szansy na trafienie krytyczne
        crit_chance = min(0.75, crit_chance)
        
        return random.random() < crit_chance

    def _get_critical_multiplier(self) -> float:
        """Zwraca mnożnik obrażeń krytycznych."""
        base_multiplier = 2.0
        
        # Modyfikatory z umiejętności
        if hasattr(self, 'get_skill_level'):
            crit_mastery = self.get_skill_level('combat', 'critical_mastery')
            if crit_mastery > 0:
                base_multiplier += crit_mastery * 0.1
        
        # Modyfikatory z efektów statusu
        for effect in self.status_effects:
            if 'crit_damage_bonus' in effect.stat_modifiers:
                base_multiplier += effect.stat_modifiers['crit_damage_bonus']
        
        return base_multiplier

    def _modify_outgoing_damage(self, damage: float, damage_type: str) -> float:
        """Modyfikuje zadawane obrażenia."""
        # Podstawowy bonus do obrażeń
        damage_bonus = 1.0
        
        # Bonus z siły
        if damage_type == 'physical':
            strength_bonus = self.current_stats.strength / 100
            damage_bonus += strength_bonus
            
        # Bonus z inteligencji dla obrażeń magicznych
        elif 'magical' in damage_type:
            intel_bonus = self.current_stats.intelligence / 100
            damage_bonus += intel_bonus
            
        # Modyfikatory z efektów statusu
        for effect in self.status_effects:
            if 'damage_dealt_modifier' in effect.stat_modifiers:
                damage_bonus += effect.stat_modifiers['damage_dealt_modifier']
                
        # Aplikuj całkowity bonus
        return damage * damage_bonus

    def heal(self, amount: float, source: Optional[str] = None) -> float:
        """Leczy jednostkę.
        
        Args:
            amount: Ilość leczenia
            source: Źródło leczenia (np. 'potion', 'spell', 'regeneration')
        
        Returns:
            float: Rzeczywista ilość przywróconego zdrowia
        """
        if not self.is_alive:
            return 0
            
        # Modyfikatory leczenia
        healing_modifier = 1.0
        
        # Modyfikatory z efektów statusu
        for effect in self.status_effects:
            if 'healing_received_modifier' in effect.stat_modifiers:
                healing_modifier *= (1 + effect.stat_modifiers['healing_received_modifier'])
        
        # Aplikuj modyfikowane leczenie
        actual_healing = amount * healing_modifier
        old_health = self.stats.health
        self.stats.health = min(self.stats.max_health, old_health + actual_healing)
        healing_done = self.stats.health - old_health
        
        # Aktualizuj statystyki
        self.combat_stats.healing_done += healing_done
        
        logger.debug(
            f"{self.name} wyleczył {healing_done:.1f} punktów zdrowia "
            f"(źródło: {source if source else 'nieznane'})"
        )
        
        return healing_done

    def die(self):
        """Obsługuje śmierć jednostki."""
        if not self.is_alive:  # Już nie żyje
            return
            
        self.is_alive = False
        self.stats.health = 0
        self.combat_stats.deaths += 1
        
        # Usuń wszystkie tymczasowe efekty statusu
        for effect in list(self.status_effects):
            if not effect.is_permanent:
                self._remove_effect(effect)
        
        # Wywołaj dodatkowe efekty śmierci
        self._trigger_death_effects()
        
        logger.info(f"{self.name} died")

    def _trigger_death_effects(self):
        """Wywołuje dodatkowe efekty przy śmierci."""
        # Może być przeciążone przez podklasy
        pass

    def resurrect(self, health_percentage: float = 0.5):
        """Wskrzesza jednostkę."""
        if self.is_alive:
            return
            
        self.is_alive = True
        self.stats.health = self.stats.max_health * health_percentage
        
        # Przywróć część zasobów
        self.stats.stamina = self.stats.max_stamina * 0.5
        self.stats.mana = self.stats.max_mana * 0.5
        
        logger.info(f"{self.name} został wskrzeszony z {self.stats.health:.1f} HP")
        
    # Kontynuacja klasy Entity

    def use_ability(self, ability_id: str, target: Optional['Entity'] = None,
                   position: Optional[Position] = None) -> Tuple[bool, str, List[Dict]]:
        """Używa zdolności.
        
        Returns:
            Tuple[bool, str, List[Dict]]: (sukces, wiadomość, lista efektów do wyświetlenia)
        """
        # Sprawdź czy zdolność jest dostępna
        can_use, message = self.can_use_ability(ability_id)
        if not can_use:
            return False, message, []
            
        ability = self.abilities[ability_id]
        effects = []
        
        # Sprawdź zasięg jeśli jest cel
        if target and not self._is_in_ability_range(target, ability):
            return False, "Cel jest poza zasięgiem!", []
            
        # Zużyj zasoby
        self.stats.stamina -= ability['cost'].get('stamina', 0)
        self.stats.mana -= ability['cost'].get('mana', 0)
        
        # Efekt podstawowy (obrażenia)
        if target and ability['damage'] > 0:
            damage = ability['damage']
            # Modyfikatory z umiejętności
            if hasattr(self, 'get_skill_level'):
                skill_bonus = self.get_skill_bonus(ability['skill_type'])
                damage *= (1 + skill_bonus)
                
            actual_damage, was_dodged, was_crit = self.deal_damage(
                target, damage, ability.get('damage_type', 'physical')
            )
            
            if was_dodged:
                return False, f"{target.name} uniknął {ability['name']}!", []
                
            effects.append({
                'type': 'damage',
                'target': target.id,
                'amount': actual_damage,
                'critical': was_crit
            })
            
            message = f"Użyto {ability['name']} zadając {actual_damage:.1f} obrażeń"
            if was_crit:
                message += " (Krytyczne!)"
        
        # Efekty obszarowe
        if ability.get('area_of_effect', 0) > 0:
            aoe_targets = self._get_targets_in_range(position or self.position, 
                                                   ability['area_of_effect'])
            for aoe_target in aoe_targets:
                if aoe_target != target:  # Nie aplikuj dwa razy do głównego celu
                    aoe_damage = ability['damage'] * 0.5  # 50% obrażeń dla celów pobocznych
                    actual_damage, _, _ = self.deal_damage(
                        aoe_target, aoe_damage, ability.get('damage_type', 'physical')
                    )
                    effects.append({
                        'type': 'damage',
                        'target': aoe_target.id,
                        'amount': actual_damage,
                        'is_aoe': True
                    })
        
        # Efekty statusu
        for effect_data in ability.get('effects', []):
            effect = StatusEffect(**effect_data)
            if target:
                target.add_status_effect(effect)
                effects.append({
                    'type': 'effect',
                    'target': target.id,
                    'effect': effect.name
                })
            else:  # Self-buff
                self.add_status_effect(effect)
                effects.append({
                    'type': 'effect',
                    'target': self.id,
                    'effect': effect.name
                })
        
        # Efekty wizualne
        if 'visual_effects' in ability:
            effects.extend(ability['visual_effects'])
        
        # Ustaw cooldown
        self._set_ability_cooldown(ability_id)
        
        return True, message, effects

    def can_use_ability(self, ability_id: str) -> Tuple[bool, str]:
        """Sprawdza czy jednostka może użyć zdolności."""
        if ability_id not in self.abilities:
            return False, "Nieznana zdolność!"
            
        ability = self.abilities[ability_id]
        
        # Sprawdź cooldown
        if self._is_on_cooldown(ability_id):
            remaining = self._get_remaining_cooldown(ability_id)
            return False, f"Zdolność odnowi się za {remaining:.1f}s!"
            
        # Sprawdź wymagane zasoby
        if self.stats.stamina < ability['cost'].get('stamina', 0):
            return False, "Niewystarczająca stamina!"
            
        if self.stats.mana < ability['cost'].get('mana', 0):
            return False, "Niewystarczająca mana!"
            
        # Sprawdź wymagania
        if not self._check_ability_requirements(ability):
            return False, "Nie spełniasz wymagań tej zdolności!"
            
        return True, ""

    def _check_ability_requirements(self, ability: dict) -> bool:
        """Sprawdza czy spełnione są wymagania zdolności."""
        requirements = ability.get('requirements', {})
        
        # Sprawdź poziom
        if 'level' in requirements and self.level < requirements['level']:
            return False
            
        # Sprawdź statystyki
        if 'stats' in requirements:
            for stat, value in requirements['stats'].items():
                if getattr(self.current_stats, stat, 0) < value:
                    return False
                    
        # Sprawdź umiejętności
        if 'skills' in requirements and hasattr(self, 'get_skill_level'):
            for skill_type, level in requirements['skills'].items():
                if self.get_skill_level(skill_type) < level:
                    return False
                    
        # Sprawdź wymagane przedmioty
        if 'items' in requirements and self.inventory:
            for item_id, count in requirements['items'].items():
                if not self.inventory.has_item(item_id, count):
                    return False
                    
        return True

    def _is_in_ability_range(self, target: 'Entity', ability: dict) -> bool:
        """Sprawdza czy cel jest w zasięgu zdolności."""
        if not hasattr(target, 'position'):
            return True
            
        ability_range = ability.get('range', 1.0)
        distance = self.position.distance_to(target.position)
        return distance <= ability_range

    def _get_targets_in_range(self, center: Position, radius: float) -> List['Entity']:
        """Znajduje wszystkie cele w zasięgu obszarowym."""
        # Ta metoda powinna być zaimplementowana przez system gry
        return []

    def _is_on_cooldown(self, ability_id: str) -> bool:
        """Sprawdza czy zdolność jest na cooldownie."""
        return ability_id in self._cooldowns and self._cooldowns[ability_id] > time.time()

    def _get_remaining_cooldown(self, ability_id: str) -> float:
        """Zwraca pozostały czas cooldownu."""
        if not self._is_on_cooldown(ability_id):
            return 0.0
        return self._cooldowns[ability_id] - time.time()

    def _set_ability_cooldown(self, ability_id: str):
        """Ustawia cooldown zdolności."""
        ability = self.abilities[ability_id]
        cooldown = ability['cooldown']
        
        # Modyfikatory redukcji czasu odnowienia
        if hasattr(self, 'get_cooldown_reduction'):
            cooldown *= (1 - self.get_cooldown_reduction())
            
        self._cooldowns[ability_id] = time.time() + cooldown

    def get_ability_info(self, ability_id: str) -> Dict:
        """Zwraca szczegółowe informacje o zdolności."""
        if ability_id not in self.abilities:
            raise InvalidSkillError(f"Nieznana zdolność: {ability_id}")
            
        ability = self.abilities[ability_id]
        info = ability.copy()
        
        # Dodaj informacje o cooldownie
        if self._is_on_cooldown(ability_id):
            info['cooldown_remaining'] = self._get_remaining_cooldown(ability_id)
        else:
            info['cooldown_remaining'] = 0
            
        # Dodaj informacje o wymaganiach
        can_use, reason = self.can_use_ability(ability_id)
        info['can_use'] = can_use
        info['cannot_use_reason'] = reason if not can_use else ""
        
        # Dodaj informacje o modyfikatorach
        if hasattr(self, 'get_skill_bonus'):
            skill_bonus = self.get_skill_bonus(ability['skill_type'])
            if 'damage' in info:
                info['modified_damage'] = info['damage'] * (1 + skill_bonus)
                
        return info

    def get_skill_bonus(self, skill_type: str) -> float:
        """Zwraca bonus z umiejętności."""
        # Ta metoda powinna być przeciążona przez klasę Player
        return 0.0

    @abstractmethod
    def get_loot(self) -> List[dict]:
        """Zwraca łup z jednostki."""
        pass

    def get_state(self) -> dict:
        """Zwraca obecny stan jednostki."""
        state = {
            'id': self.id,
            'name': self.name,
            'level': self.level,
            'health': self.stats.health,
            'max_health': self.stats.max_health,
            'stamina': self.stats.stamina,
            'status_effects': [
                {
                    'name': effect.name,
                    'duration': effect.duration,
                    'type': effect.type
                }
                for effect in self.status_effects
            ],
            'position': {
                'x': self.position.x,
                'y': self.position.y,
                'z': self.position.z
            },
            'is_alive': self.is_alive,
            'in_combat': self.in_combat,
            'combat_stats': self.combat_stats.__dict__,
            'cooldowns': {
                ability_id: remaining 
                for ability_id, remaining in self._cooldowns.items()
                if remaining > time.time()
            }
        }
        
        # Dodaj informacje o ekwipunku jeśli istnieje
        if self.inventory:
            state['inventory'] = self.inventory.get_state()
            
        return state
    
class Character(Entity):
    """Klasa reprezentująca postacie niezależne (NPC)."""
    
    def __init__(self, char_id: str, data: dict):
        super().__init__(char_id, data)
        
        # Podstawowe atrybuty NPC
        self.faction = data.get('faction', 'neutral')
        self.relations = data.get('relations', {})
        self.dialogues = data.get('dialogues', [])
        self.shop_items = data.get('shop_items', [])
        self.quest_giver = data.get('quest_giver', False)
        self.behavior = data.get('behavior', 'friendly')
        
        # System aktywności dobowej
        self.daily_schedule = data.get('daily_schedule', {})
        self.current_activity = None
        self.home_location = data.get('home_location')
        self.work_location = data.get('work_location')
        
        # System interakcji
        self.available_services = data.get('services', [])
        self.interaction_cooldown = 0
        self.conversation_topics = data.get('conversation_topics', {})
        self.knowledge = data.get('knowledge', {})
        
        # System relacji
        self.friendship_level = {}
        self.trust_level = {}
        self.last_interaction = {}
        self.interaction_history = []
        
        # Inicjalizacja dodatkowych systemów
        self._initialize_services()
        self._initialize_schedule()
        self._initialize_ai()

    def _initialize_services(self):
        """Inicjalizuje usługi oferowane przez NPC."""
        self.services = {}
        for service_data in self.available_services:
            service_type = service_data['type']
            if service_type == 'merchant':
                self.services['trade'] = {
                    'enabled': True,
                    'specialization': service_data.get('specialization', 'general'),
                    'markup': service_data.get('markup', 1.0),
                    'min_reputation': service_data.get('min_reputation', -100)
                }
            elif service_type == 'trainer':
                self.services['training'] = {
                    'skills': service_data.get('skills', []),
                    'max_level': service_data.get('max_level', 5),
                    'cost_per_level': service_data.get('cost_per_level', 100)
                }
            elif service_type == 'questgiver':
                self.services['quests'] = {
                    'quest_types': service_data.get('quest_types', []),
                    'min_level': service_data.get('min_level', 1),
                    'reputation_requirement': service_data.get('reputation_requirement', 0)
                }

    def _initialize_schedule(self):
        """Inicjalizuje harmonogram dzienny NPC."""
        self.schedule = {}
        for time_range, activity_data in self.daily_schedule.items():
            start, end = map(int, time_range.split('-'))
            self.schedule[time_range] = {
                'activity': activity_data['type'],
                'location': activity_data.get('location'),
                'interactions': activity_data.get('available_interactions', []),
                'dialogue_set': activity_data.get('dialogue_set', 'default'),
                'conditions': activity_data.get('conditions', {})
            }

    def _initialize_ai(self):
        """Inicjalizuje system sztucznej inteligencji NPC."""
        self.ai_state = {
            'current_goal': None,
            'current_path': [],
            'known_threats': set(),
            'interest_points': {},
            'memory': {},
            'emotional_state': 'neutral',
            'behavior_flags': set()
        }

    def update(self, game_time: float):
        """Aktualizuje stan NPC."""
        super().update(game_time)
        
        # Aktualizacja aktywności
        self._update_activity(game_time)
        
        # Aktualizacja AI
        self._update_ai(game_time)
        
        # Aktualizacja relacji
        self._update_relations(game_time)
        
        # Aktualizacja usług
        self._update_services(game_time)

    def _update_activity(self, game_time: float):
        """Aktualizuje aktywność NPC na podstawie harmonogramu."""
        current_hour = int((game_time / 3600) % 24)
        
        # Znajdź odpowiednią aktywność dla aktualnej godziny
        for time_range, activity_data in self.schedule.items():
            start, end = map(int, time_range.split('-'))
            if start <= current_hour < end:
                if self.current_activity != activity_data['activity']:
                    self._change_activity(activity_data)
                break

    def _change_activity(self, activity_data: dict):
        """Zmienia aktualną aktywność NPC."""
        self.current_activity = activity_data['activity']
        target_location = activity_data.get('location')
        
        if target_location and target_location != self.position:
            self._plan_path_to(target_location)
            
        # Aktualizuj dostępne interakcje
        self.available_interactions = activity_data.get('interactions', [])
        
        # Ustaw odpowiedni zestaw dialogów
        self.current_dialogue_set = activity_data.get('dialogue_set', 'default')
        
        logger.debug(
            f"{self.name} zmienił aktywność na {self.current_activity} "
            f"w lokacji {target_location or 'obecna'}"
        )

    def _plan_path_to(self, target_location: str):
        """Planuje ścieżkę do celu."""
        self.ai_state['current_path'] = self._find_path_to(target_location)
        if self.ai_state['current_path']:
            self.ai_state['current_goal'] = {
                'type': 'move_to',
                'target': target_location,
                'reason': 'schedule'
            }

    def _find_path_to(self, target_location: str) -> List[str]:
        """Znajduje ścieżkę do celu."""
        # Ta metoda powinna być zaimplementowana przez system nawigacji świata
        return []
    
    # Kontynuacja klasy Character

    def interact(self, player: 'Player') -> Tuple[bool, str, Dict]:
        """Podstawowa interakcja z NPC."""
        if not self._can_interact(player):
            return False, f"{self.name} nie chce teraz rozmawiać.", {}
            
        # Aktualizuj historię interakcji
        self._record_interaction(player.id, 'talk')
        
        # Sprawdź specjalne dialogi dla questów
        if special_dialogue := self._get_quest_dialogue(player):
            return True, special_dialogue['text'], special_dialogue['data']
            
        # Generuj odpowiednią odpowiedź bazując na relacjach i sytuacji
        response = self._generate_response(player)
        
        # Aktualizuj relacje
        self._update_relationship(player.id, 'talk')
        
        return True, response['text'], response['data']

    def _can_interact(self, player: 'Player') -> bool:
        """Sprawdza czy interakcja jest możliwa."""
        # Sprawdź cooldown interakcji
        if time.time() < self.interaction_cooldown:
            return False
            
        # Sprawdź czy aktywność pozwala na interakcję
        if self.current_activity in ['sleeping', 'busy', 'unavailable']:
            return False
            
        # Sprawdź relacje
        if self.faction in player.reputation:
            if player.reputation[self.faction] < -75:  # Skrajna wrogość
                return False
                
        # Sprawdź warunki interakcji dla obecnej aktywności
        if not self._check_activity_conditions(player):
            return False
            
        return True

    def _check_activity_conditions(self, player: 'Player') -> bool:
        """Sprawdza warunki interakcji dla obecnej aktywności."""
        if not self.current_activity:
            return True
            
        activity_data = next(
            (data for _, data in self.schedule.items() 
             if data['activity'] == self.current_activity),
            None
        )
        
        if not activity_data:
            return True
            
        conditions = activity_data.get('conditions', {})
        
        # Sprawdź wymagany poziom gracza
        if 'min_level' in conditions and player.level < conditions['min_level']:
            return False
            
        # Sprawdź wymagane relacje
        if 'min_reputation' in conditions:
            for faction, value in conditions['min_reputation'].items():
                if player.reputation.get(faction, 0) < value:
                    return False
                    
        # Sprawdź wymagane questy
        if 'required_quests' in conditions:
            for quest_id in conditions['required_quests']:
                if quest_id not in player.completed_quests:
                    return False
                    
        return True

    def _record_interaction(self, player_id: str, interaction_type: str):
        """Zapisuje interakcję w historii."""
        self.interaction_history.append({
            'player_id': player_id,
            'type': interaction_type,
            'timestamp': time.time(),
            'location': self.position,
            'activity': self.current_activity
        })
        
        # Ogranicz historię do ostatnich 100 interakcji
        if len(self.interaction_history) > 100:
            self.interaction_history = self.interaction_history[-100:]

    def _update_relationship(self, player_id: str, interaction_type: str):
        """Aktualizuje relacje z graczem."""
        # Inicjalizuj relacje jeśli nie istnieją
        if player_id not in self.friendship_level:
            self.friendship_level[player_id] = 0
        if player_id not in self.trust_level:
            self.trust_level[player_id] = 0
            
        # Podstawowe zmiany bazowane na typie interakcji
        changes = {
            'talk': {'friendship': 1, 'trust': 0},
            'trade': {'friendship': 0, 'trust': 1},
            'quest_complete': {'friendship': 5, 'trust': 3},
            'quest_fail': {'friendship': -3, 'trust': -5},
            'gift': {'friendship': 3, 'trust': 1},
            'help': {'friendship': 2, 'trust': 2}
        }
        
        if interaction_type in changes:
            change = changes[interaction_type]
            self._modify_relationship(player_id, change['friendship'], change['trust'])

    def _modify_relationship(self, player_id: str, friendship_change: int, trust_change: int):
        """Modyfikuje poziomy przyjaźni i zaufania."""
        # Aplikuj zmiany z uwzględnieniem limitów
        self.friendship_level[player_id] = max(-100, min(100, 
            self.friendship_level[player_id] + friendship_change))
        self.trust_level[player_id] = max(-100, min(100, 
            self.trust_level[player_id] + trust_change))
            
        # Zapisz czas ostatniej interakcji
        self.last_interaction[player_id] = time.time()

    def get_relationship_status(self, player_id: str) -> Dict[str, Any]:
        """Zwraca status relacji z graczem."""
        friendship = self.friendship_level.get(player_id, 0)
        trust = self.trust_level.get(player_id, 0)
        
        # Określ ogólny status relacji
        if friendship >= 75 and trust >= 75:
            status = "Najlepszy przyjaciel"
        elif friendship >= 50:
            status = "Przyjaciel"
        elif friendship >= 25:
            status = "Znajomy"
        elif friendship >= 0:
            status = "Neutralny"
        elif friendship >= -25:
            status = "Nieufny"
        elif friendship >= -50:
            status = "Wrogi"
        else:
            status = "Nieprzyjaciel"
            
        return {
            'status': status,
            'friendship': friendship,
            'trust': trust,
            'last_interaction': self.last_interaction.get(player_id, 0),
            'interaction_count': len([x for x in self.interaction_history 
                                   if x['player_id'] == player_id])
        }

    def _generate_response(self, player: 'Player') -> Dict[str, Any]:
        """Generuje odpowiednią odpowiedź dla gracza."""
        # Weź pod uwagę aktualną aktywność
        activity_responses = self._get_activity_responses()
        
        # Weź pod uwagę relacje
        relationship = self.get_relationship_status(player.id)
        
        # Weź pod uwagę emocjonalny stan NPC
        emotional_responses = self._get_emotional_responses()
        
        # Weź pod uwagę wiedzę o questach gracza
        quest_responses = self._get_quest_related_responses(player)
        
        # Wybierz najlepszą odpowiedź bazując na priorytetach
        if quest_responses:
            response = quest_responses
        elif any(self.ai_state['known_threats']):
            response = self._get_threat_response()
        elif activity_responses:
            response = activity_responses
        else:
            response = self._get_default_response(relationship)
            
        return response

    def _get_activity_responses(self) -> Optional[Dict[str, Any]]:
        """Zwraca odpowiedzi związane z aktualną aktywnością."""
        if not self.current_activity:
            return None
            
        responses = {
            'sleeping': {
                'text': "Zzz... *NPC śpi głęboko*",
                'data': {'type': 'sleeping', 'can_wake': False}
            },
            'working': {
                'text': "Przepraszam, ale jestem teraz zajęty pracą.",
                'data': {'type': 'working', 'can_interrupt': False}
            },
            'eating': {
                'text': "Właśnie jem posiłek. Może porozmawiamy później?",
                'data': {'type': 'eating', 'can_join': True}
            },
            'shopping': {
                'text': "Rozglądam się za towarem.",
                'data': {'type': 'shopping', 'can_help': True}
            }
        }
        
        return responses.get(self.current_activity)

    def _get_emotional_responses(self) -> Optional[Dict[str, Any]]:
        """Zwraca odpowiedzi bazujące na stanie emocjonalnym."""
        emotional_state = self.ai_state['emotional_state']
        
        responses = {
            'happy': {
                'text': "Witaj! Dziś jest wspaniały dzień, prawda?",
                'data': {'mood': 'positive', 'gesture': 'smile'}
            },
            'angry': {
                'text': "Czego chcesz? Lepiej mnie dziś nie denerwuj!",
                'data': {'mood': 'negative', 'gesture': 'frown'}
            },
            'scared': {
                'text': "N-nie podchodź zbyt blisko...",
                'data': {'mood': 'negative', 'gesture': 'step_back'}
            },
            'sad': {
                'text': "*wzdycha* Tak...?",
                'data': {'mood': 'negative', 'gesture': 'sigh'}
            }
        }
        
        return responses.get(emotional_state)Plik: ./exceptions.py
# exceptions.py

class GameError(Exception):
    """Bazowy wyjątek dla wszystkich błędów w grze."""
    pass

class ItemError(GameError):
    """Błędy związane z przedmiotami."""
    pass

class InventoryError(GameError):
    """Błędy związane z ekwipunkiem."""
    pass

class QuestError(GameError):
    """Błędy związane z questami."""
    pass

class CombatError(GameError):
    """Błędy związane z systemem walki."""
    pass

class SaveLoadError(GameError):
    """Błędy związane z zapisem/odczytem gry."""
    pass

class InvalidItemError(ItemError):
    """Próba użycia nieprawidłowego przedmiotu."""
    pass

class ItemNotFoundError(ItemError):
    """Przedmiot nie został znaleziony."""
    pass

class InventoryFullError(InventoryError):
    """Ekwipunek jest pełny."""
    pass

class InsufficientFundsError(InventoryError):
    """Niewystarczająca ilość złota."""
    pass

class RequirementsNotMetError(ItemError):
    """Wymagania przedmiotu nie są spełnione."""
    pass

class QuestNotAvailableError(QuestError):
    """Quest nie jest dostępny."""
    pass

class QuestAlreadyActiveError(QuestError):
    """Quest jest już aktywny."""
    pass

class QuestNotCompleteError(QuestError):
    """Quest nie został ukończony."""
    pass

class CombatAlreadyInProgressError(CombatError):
    """Walka jest już w toku."""
    pass

class NotInCombatError(CombatError):
    """Akcja wymaga bycia w walce."""
    pass

class InvalidTargetError(CombatError):
    """Nieprawidłowy cel ataku."""
    pass

class SaveFileCorruptedError(SaveLoadError):
    """Plik zapisu jest uszkodzony."""
    pass

class SaveVersionMismatchError(SaveLoadError):
    """Niezgodna wersja pliku zapisu."""
    pass

class GameStateError(GameError):
    """Błędy związane ze stanem gry."""
    pass

class LocationError(GameError):
    """Błędy związane z lokacjami."""
    
    def __init__(self, message: str, location_id: str = None):
        super().__init__(message)
        self.location_id = location_id

class InvalidLocationError(LocationError):
    """Próba dostępu do nieprawidłowej lokacji."""
    pass

class LocationAccessError(LocationError):
    """Brak dostępu do lokacji."""
    pass

class DialogueError(GameError):
    """Błędy związane z systemem dialogów."""
    pass

class InvalidDialogueOptionError(DialogueError):
    """Wybrano nieprawidłową opcję dialogową."""
    pass

class TradeError(GameError):
    """Błędy związane z systemem handlu."""
    pass

class InvalidTradeError(TradeError):
    """Nieprawidłowa transakcja handlowa."""
    pass

class ResourceError(GameError):
    """Błędy związane z zasobami."""
    pass

class ResourceNotFoundError(ResourceError):
    """Zasób nie został znaleziony."""
    pass

class SkillError(GameError):
    """Błędy związane z umiejętnościami."""
    pass

class InvalidSkillError(SkillError):
    """Próba użycia nieprawidłowej umiejętności."""
    pass

class InsufficientSkillLevelError(SkillError):
    """Niewystarczający poziom umiejętności."""
    pass

def handle_game_error(error: GameError) -> str:
    """Konwertuje wyjątki gry na przyjazne dla użytkownika komunikaty."""
    error_messages = {
        InventoryFullError: "Twój ekwipunek jest pełny!",
        InsufficientFundsError: "Nie masz wystarczająco złota!",
        RequirementsNotMetError: "Nie spełniasz wymagań tego przedmiotu!",
        QuestNotAvailableError: "Ten quest nie jest obecnie dostępny.",
        QuestAlreadyActiveError: "Ten quest jest już aktywny!",
        CombatAlreadyInProgressError: "Już jesteś w trakcie walki!",
        InvalidTargetError: "Nieprawidłowy cel ataku!",
        LocationAccessError: "Nie możesz wejść do tej lokacji!",
        InvalidSkillError: "Nie znasz tej umiejętności!",
        InsufficientSkillLevelError: "Twój poziom umiejętności jest zbyt niski!"
    }
    
    # Znajdź najbardziej szczegółowy komunikat błędu
    for error_type, message in error_messages.items():
        if isinstance(error, error_type):
            return message
            
    # Domyślny komunikat
    return str(error)Plik: ./game.py
# game.py
import time
import logging
from typing import Optional, Dict, List, Any
from dataclasses import dataclass
from config import game_config
from world import World
from player import Player
from character import CharacterManager
from items import ItemManager
from combat import CombatSystem
from quests import QuestManager
from interface import GameInterface

logger = logging.getLogger(__name__)

@dataclass
class GameTime:
    """Zarządzanie czasem w grze."""
    real_start_time: float = 0.0
    game_start_time: float = 0.0
    time_scale: float = 24.0  # 1 minuta realna = 24 minuty w grze
    
    def get_game_time(self) -> float:
        """Zwraca aktualny czas gry w sekundach."""
        real_elapsed = time.time() - self.real_start_time
        return self.game_start_time + (real_elapsed * self.time_scale)
    
    def format_game_time(self) -> str:
        """Formatuje czas gry do czytelnej postaci."""
        total_seconds = int(self.get_game_time())
        hours = (total_seconds // 3600) % 24
        minutes = (total_seconds % 3600) // 60
        return f"{hours:02d}:{minutes:02d}"

class GameEngine:
    """Główny silnik gry integrujący wszystkie systemy."""
    
    def __init__(self):
        self.game_time = GameTime(time.time(), 0.0)
        self.running = False
        self.paused = False
        
        # Inicjalizacja głównych systemów
        logger.info("Inicjalizacja systemów gry...")
        self.world = World()
        self.item_manager = ItemManager()
        self.character_manager = CharacterManager()
        self.quest_manager = QuestManager()
        self.combat_system = CombatSystem()
        self.interface = GameInterface()
        
       
        
        # Stan gry
        self.active_dialogs = {}
        self.active_trades = {}
        self.active_combats = {}
        self.event_queue = []
        self.message_queue = []
        
        logger.info("Inicjalizacja zakończona")

    def new_game(self, player_name: str):
        """Rozpoczyna nową grę."""
        logger.info(f"Rozpoczynanie nowej gry dla gracza: {player_name}")
    
        # Tworzenie nowej postaci
        player_data = {
            'name': player_name,
            'level': 1,
            'stats': {
                'health': 100,
                'max_health': 100,
                'stamina': 100,
                'max_stamina': 100,
                'mana': 50,
                'max_mana': 50,
                'strength': 10,
                'defense': 5,
                'agility': 10,
                'intelligence': 10
            },
            'gold': 100
        }
    
        self.player = Player('player', player_data)
    
        # Inicjalizacja podstawowych systemów dla gracza
        self.player.initialize_inventory(self.item_manager)
        self.player.initialize_quests(self.quest_manager)
    
        # Ustawienie początkowej lokacji
        starting_location = game_config.get('gameplay.starting_location', 'miasto_startowe')
        self.player.current_location = starting_location
    
        # Rozpoczęcie gry
        self.running = True
        self.game_time.real_start_time = time.time()
    
        # Pokaż początkowy opis
        location = self.world.get_location(starting_location)
        return f"Witaj {player_name}! Rozpoczynasz przygodę w {location.name}.\n{location.description}"

    def _give_starting_items(self):
        """Dodaje początkowe przedmioty dla gracza."""
        starting_items = game_config.get('gameplay.starting_items', {})
        for item_id, amount in starting_items.items():
            self.player.inventory.add_item(item_id, amount)

    def load_game(self, save_data: dict) -> tuple[bool, str]:
        """Wczytuje zapisaną grę."""
        try:
            logger.info("Wczytywanie zapisanej gry...")
            
            # Wczytaj dane gracza
            self.player = Player(save_data['player_data']['basic_info']['name'])
            success, message = self.player.load_game(save_data)
            if not success:
                return False, message
            
            # Wczytaj stan świata
            self.world.load_state(save_data.get('world_state', {}))
            
            # Wczytaj stan NPCs
            self.character_manager.load_state(save_data.get('npc_state', {}))
            
            # Ustaw czas gry
            self.game_time.game_start_time = save_data['game_state']['game_time']
            self.game_time.real_start_time = time.time()
            
            self.running = True
            logger.info("Gra wczytana pomyślnie")
            return True, "Pomyślnie wczytano grę!"
            
        except Exception as e:
            logger.error(f"Błąd podczas wczytywania gry: {e}")
            return False, "Wystąpił błąd podczas wczytywania gry!"

    def save_game(self) -> tuple[bool, str, Optional[dict]]:
        """Zapisuje stan gry."""
        try:
            logger.info("Zapisywanie stanu gry...")
            
            save_data = {
                'player_data': self.player.save_game()['player_data'],
                'world_state': self.world.get_state(),
                'npc_state': self.character_manager.get_state(),
                'game_state': {
                    'game_time': self.game_time.get_game_time(),
                    'version': game_config.get('version')
                }
            }
            
            return True, "Gra została zapisana!", save_data
            
        except Exception as e:
            logger.error(f"Błąd podczas zapisywania gry: {e}")
            return False, "Wystąpił błąd podczas zapisywania gry!", None

    def update_game_state(self):
        """Aktualizuje stan gry."""
        if not self.running or self.paused:
            return
            
        # Aktualizacja świata
        self.world.update(self.game_time.get_game_time())
        
        # Aktualizacja gracza
        self.player.update(self.game_time.get_game_time())
        
        # Aktualizacja NPC
        self.character_manager.update(self.game_time.get_game_time())
        
        # Aktualizacja aktywnych walk
        self._update_combats()   
        
        # Przetwarzanie kolejki wydarzeń
        self._process_event_queue ()  
        
        # Przetwarzanie kolejki wiadomości
        self._process_message_queue()

    def handle_command(self, command: str) -> str:
        """Obsługuje komendy gracza."""
        if not self.running:
            return "Gra nie jest uruchomiona!"
            
        if not self.player:
            return "Gracz nie został zainicjalizowany!"
            
        command = command.lower().strip()
        
        # Podstawowe komendy
        if command == "rozejrzyj się":
            location = self.world.get_location(self.player.current_location)
            return f"\n=== {location.name} ===\n{location.description}"
        elif command == "status":
            return self.interface.show_status(self.player)
        elif command == "ekwipunek":
            return self.interface.show_inventory(self.player)
        elif command == "questy":
            return self.interface.show_quests(self.player)
        elif command == "pomoc":
            return self.interface.show_help()
        else:
            return "Nieznana komenda. Wpisz 'pomoc' aby zobaczyć dostępne komendy."

    def _update_combats(self):
        """Aktualizuje stan aktywnych walk."""
        for combat_id, combat in list(self.active_combats.items()):
            if combat.is_finished():
                self._handle_combat_end(combat)
                del self.active_combats[combat_id]
            else:
                combat.update()

    def _handle_combat_end(self, combat):
        """Obsługuje zakończenie walki."""
        result = combat.get_result()
        if result.winner == self.player:
            self._handle_combat_victory(combat)
        elif result.winner == combat.enemy:
            self._handle_combat_defeat(combat)

    def _handle_combat_victory(self, combat):
        """Obsługuje zwycięstwo w walce."""
        # Przyznaj doświadczenie
        exp_gained = combat.enemy.experience_value
        self.player.gain_experience(exp_gained)
        
        # Zbierz łup
        loot = combat.enemy.get_loot()
        for item in loot:
            self.player.inventory.add_item(item['id'], item['amount'])
            
        # Aktualizuj questy
        self.player.update_quest_progress('kill', combat.enemy.id)
        
        # Aktualizuj statystyki
        self.player.player_stats['monsters_killed'] += 1

    def _handle_combat_defeat(self, combat):
        """Obsługuje porażkę w walce."""
        # Kary za śmierć
        self.player.apply_death_penalty()
        
        # Przywróć gracza do ostatniego bezpiecznego punktu
        self._respawn_player()

    def _respawn_player(self):
        """Przywraca gracza po śmierci."""
        # Znajdź najbliższy bezpieczny punkt
        spawn_point = self.world.get_nearest_safe_location(self.player.current_location)
        
        # Teleportuj gracza
        self.player.current_location = spawn_point
        
        # Przywróć podstawowe statystyki
        self.player.stats.health = self.player.stats.max_health // 2
        self.player.stats.stamina = self.player.stats.max_stamina
        self.player.stats.mana = self.player.stats.max_mana

    def _process_event_queue(self):
        """Przetwarza kolejkę wydarzeń."""
        while self.event_queue:
            event = self.event_queue.pop(0)
            try:
                self._handle_event(event)
            except Exception as e:
                logger.error(f"Błąd podczas przetwarzania wydarzenia: {e}")

    def _handle_event(self, event):
        """Obsługuje pojedyncze wydarzenie."""
        event_type = event['type']
        
        if event_type == 'quest_update':
            self.player.update_quest_progress(
                event['objective_type'],
                event['target_id'],
                event.get('amount', 1)
            )
        elif event_type == 'world_event':
            self.world.trigger_event(event['event_id'])
        elif event_type == 'combat_start':
            self._start_combat(event['enemy_id'])
        elif event_type == 'item_pickup':
            self.player.pickup_item(event['item_id'])

    def _process_message_queue(self):
        """Przetwarza kolejkę wiadomości."""
        while self.message_queue:
            message = self.message_queue.pop(0)
            self.interface.show_message(message['text'], message['type'])

    command_handlers = {
        'idz': lambda self, args: self._handle_move(args),
        'atakuj': lambda self, args: self._handle_attack(args),
        'uzyj': lambda self, args: self._handle_use(args),
        'ekwipunek': lambda self, args: self._handle_inventory(args),
        'rozmawiaj': lambda self, args: self._handle_talk(args),
        'handluj': lambda self, args: self._handle_trade(args),
        'pomoc': lambda self, args: self._show_help(),
        'status': lambda self, args: self._show_status(),
        'questy': lambda self, args: self._show_quests(),
        'umiejetnosci': lambda self, args: self._show_skills(),
        'zapisz': lambda self, args: self._handle_save(),
        'wczytaj': lambda self, args: self._handle_load(args)
    }

    # Implementacje handlerów komend...
    # Kontynuacja klasy GameEngine

    def _handle_move(self, args: List[str]) -> str:
        """Obsługa komendy poruszania się."""
        if not args:
            available_exits = self.world.get_location(self.player.current_location).exits
            return f"Dokąd chcesz iść? Dostępne kierunki: {', '.join(available_exits)}"

        destination = ' '.join(args).lower()
        current_location = self.world.get_location(self.player.current_location)
        
        if destination not in current_location.exits:
            return "Nie możesz tam pójść!"
            
        # Sprawdź czy gracz może wejść do lokacji
        new_location = self.world.get_location(destination)
        can_enter, reason = new_location.can_enter(self.player)
        if not can_enter:
            return reason
            
        # Sprawdź czy są aktywne walki
        if self.active_combats:
            return "Nie możesz się przemieszczać podczas walki!"
            
        # Wykonaj ruch
        old_location = self.player.current_location
        self.player.current_location = destination
        self.player.known_locations.add(destination)
        
        # Aktualizuj statystyki
        self.player.player_stats['distance_traveled'] += 1
        
        # Sprawdź questy
        self.player.update_quest_progress('visit', destination)
        
        # Opisz nową lokację
        description = self._get_location_description(new_location)
        
        # Sprawdź i aktywuj wydarzenia w nowej lokacji
        self._check_location_events(new_location)
        
        return description

    def _get_location_description(self, location) -> str:
        """Generuje opis lokacji z uwzględnieniem wszystkich elementów."""
        description = [f"\n=== {location.name} ===\n"]
        description.append(location.description)
        
        # Dodaj opis pogody
        if location.weather:
            description.append(f"\nPogoda: {location.weather.description}")
            
        # Pokaż NPC
        npcs = self.character_manager.get_characters_in_location(location.id)
        if npcs:
            description.append("\nPostacie w pobliżu:")
            for npc in npcs:
                if not npc.is_enemy:
                    description.append(f"- {npc.name}")
                    
        # Pokaż przeciwników
        enemies = [npc for npc in npcs if npc.is_enemy]
        if enemies and self.player.get_skill_level('tracking') > 0:
            description.append("\nPrzeciwników w pobliżu:")
            for enemy in enemies:
                description.append(f"- {enemy.name} (Poziom {enemy.level})")
                
        # Pokaż przedmioty
        if location.items:
            description.append("\nPrzedmioty w pobliżu:")
            for item_id in location.items:
                item = self.item_manager.get_item(item_id)
                description.append(f"- {item.name}")
                
        # Pokaż zasoby
        if location.resources and self.player.get_skill_level('gathering') > 0:
            description.append("\nDostępne zasoby:")
            for resource in location.resources:
                if resource.quantity > 0:
                    description.append(f"- {resource.type} (x{resource.quantity})")
                    
        # Pokaż wyjścia
        description.append("\nMożliwe kierunki:")
        description.append(", ".join(location.exits))
        
        return "\n".join(description)

    def _handle_attack(self, args: List[str]) -> str:
        """Obsługa komendy ataku."""
        if not args:
            return "Kogo chcesz zaatakować?"
            
        target_name = ' '.join(args).lower()
        current_location = self.world.get_location(self.player.current_location)
        
        # Znajdź przeciwnika
        enemies = [npc for npc in self.character_manager.get_characters_in_location(current_location.id)
                  if npc.is_enemy and npc.name.lower() == target_name]
                  
        if not enemies:
            return "Nie ma tu takiego przeciwnika!"
            
        enemy = enemies[0]
        
        # Sprawdź czy walka jest już aktywna
        if enemy.id in self.active_combats:
            return "Już walczysz z tym przeciwnikiem!"
            
        # Rozpocznij walkę
        combat = self.combat_system.start_combat(self.player, enemy)
        self.active_combats[enemy.id] = combat
        
        # Pokaż interfejs walki
        self.interface.show_combat_interface(combat)
        
        return f"Rozpoczęto walkę z {enemy.name}!"

    def _handle_use(self, args: List[str]) -> str:
        """Obsługa komendy użycia przedmiotu lub zdolności."""
        if not args:
            return "Co chcesz użyć?"
            
        item_or_ability = ' '.join(args).lower()
        
        # Najpierw sprawdź czy to przedmiot
        item_id = self.item_manager.get_item_id_by_name(item_or_ability)
        if item_id and self.player.inventory.has_item(item_id):
            success, message = self.player.inventory.use_item(item_id, self.player)
            if success:
                self._check_item_use_achievements(item_id)
            return message
            
        # Jeśli nie przedmiot, sprawdź czy to zdolność
        for ability_id, ability in self.player.abilities.items():
            if ability['name'].lower() == item_or_ability:
                success, message = self.player.use_ability(ability_id)
                return message
                
        return "Nie możesz tego użyć!"

    def _handle_inventory(self, args: List[str]) -> str:
        """Obsługa komendy ekwipunku."""
        if not args:
            # Pokaż całe ekwipunek
            return self.interface.show_inventory(self.player.inventory, self.player.equipment_slots)
            
        action = args[0].lower()
        if len(args) < 2:
            return "Określ przedmiot!"
            
        item_name = ' '.join(args[1:])
        item_id = self.item_manager.get_item_id_by_name(item_name)
        
        if not item_id:
            return "Nie ma takiego przedmiotu!"
            
        if action == "zaloz":
            success, message = self.player.equip_item(item_id)
        elif action == "zdejmij":
            success, message = self.player.unequip_item(item_id)
        elif action == "wyrzuc":
            success, message = self.player.inventory.remove_item(item_id)
        else:
            return "Nieznana akcja! Dostępne: zaloz, zdejmij, wyrzuc"
            
        return message

    def _handle_talk(self, args: List[str]) -> str:
        """Obsługa komendy rozmowy z NPC."""
        if not args:
            return "Z kim chcesz porozmawiać?"
            
        npc_name = ' '.join(args).lower()
        npcs = self.character_manager.get_characters_in_location(self.player.current_location)
        
        npc = next((n for n in npcs if n.name.lower() == npc_name), None)
        if not npc:
            return "Nie ma tu takiej osoby!"
            
        # Sprawdź czy NPC nie jest w trakcie innej rozmowy
        if npc.id in self.active_dialogs:
            return f"{npc.name} jest zajęty rozmową z kimś innym!"
            
        # Rozpocznij dialog
        dialog = self.interface.start_dialog(npc, self.player)
        self.active_dialogs[npc.id] = dialog
        
        return dialog.get_current_text()

    def _handle_trade(self, args: List[str]) -> str:
        """Obsługa komendy handlu."""
        current_location = self.world.get_location(self.player.current_location)
        merchants = [npc for npc in self.character_manager.get_characters_in_location(current_location.id)
                    if isinstance(npc, Merchant)]
                    
        if not merchants:
            return "Nie ma tu nikogo do handlu!"
            
        merchant = merchants[0]
        if merchant.id in self.active_trades:
            return "Już handlujesz z tym kupcem!"
            
        # Rozpocznij handel
        trade_session = self.interface.start_trade(merchant, self.player)
        self.active_trades[merchant.id] = trade_session
        
        return f"Rozpoczęto handel z {merchant.name}!"

    def _show_help(self) -> str:
        """Pokazuje pomoc dotyczącą dostępnych komend."""
        return self.interface.show_help(self.command_handlers.keys())

    def _show_status(self) -> str:
        """Pokazuje status gracza."""
        return self.interface.show_status(self.player)

    def _show_quests(self) -> str:
        """Pokazuje dziennik questów."""
        return self.interface.show_quest_log(
            self.player.active_quests,
            self.player.completed_quests,
            self.quest_manager.get_available_quests(self.player)
        )

    def _show_skills(self) -> str:
        """Pokazuje umiejętności gracza."""
        return self.interface.show_skills(self.player.skills, self.player.skill_experience)

    def _handle_save(self) -> str:
        """Obsługa zapisu gry."""
        success, message, save_data = self.save_game()
        if success and game_config.get('game_settings.auto_backup', True):
            self._create_backup(save_data)
        return message

    def _handle_load(self, args: List[str]) -> str:
        """Obsługa wczytywania gry."""
        if not args:
            return "Podaj nazwę zapisu!"
            
        save_name = ' '.join(args)
        try:
            save_data = self._load_save_data(save_name)
            success, message = self.load_game(save_data)
            return message
        except Exception as e:
            logger.error(f"Błąd podczas wczytywania zapisu: {e}")
            return "Wystąpił błąd podczas wczytywania zapisu!"

    def _check_location_events(self, location) -> None:
        """Sprawdza i aktywuje wydarzenia w lokacji."""
        current_time = self.game_time.get_game_time()
        
        for event in location.events:
            if event.should_trigger(current_time, self.player):
                self.event_queue.append({
                    'type': 'world_event',
                    'event_id': event.id,
                    'location_id': location.id
                })

    def _check_item_use_achievements(self, item_id: str) -> None:
        """Sprawdza i przyznaje osiągnięcia związane z użyciem przedmiotów."""
        item = self.item_manager.get_item(item_id)
        
        if item.type == 'potion':
            self.player.player_stats['potions_used'] += 1
            if self.player.player_stats['potions_used'] >= 100:
                self.player.unlock_achievement('potion_master')
        elif item.type == 'scroll':
            self.player.player_stats['scrolls_used'] += 1
            if self.player.player_stats['scrolls_used'] >= 50:
                self.player.unlock_achievement('scroll_sage')

    def _create_backup(self, save_data: dict) -> None:
        """Tworzy kopię zapasową stanu gry."""
        try:
            backup_path = f"saves/backup_{int(time.time())}.json"
            with open(backup_path, 'w', encoding='utf-8') as f:
                json.dump(save_data, f, indent=4)
            logger.info(f"Utworzono kopię zapasową: {backup_path}")
        except Exception as e:
            logger.error(f"Błąd podczas tworzenia kopii zapasowej: {e}")

    def _load_save_data(self, save_name: str) -> dict:
        """Wczytuje dane zapisu."""
        save_path = f"saves/{save_name}.json"
        try:
            with open(save_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except FileNotFoundError:
            raise ValueError(f"Nie znaleziono zapisu o nazwie {save_name}")
        except json.JSONDecodeError:
            raise ValueError(f"Uszkodzony plik zapisu: {save_name}")Plik: ./gui.py
# gui.py
import tkinter as tk
from tkinter import ttk, scrolledtext, font
from functools import partial
import sys
from game import GameEngine
from colorama import Fore, Style

class ModernGameGUI:
    def __init__(self, game_instance):
        self.game = game_instance
        if not self.game or not self.game.player:
            raise ValueError("Game engine lub player nie zostały prawidłowo zainstalizowane")
        
        self.setup_window()
        # Ustaw referencję do głównego okna w game engine
        self.game.root = self.root
        self.setup_styles()
        self.setup_widgets()
        self.setup_output_redirect()
        self.setup_command_buttons()
        self.setup_bindings()
        
        # Upewnij się, że gra jest uruchomiona
        if not self.game.running:
            self.game.running = True
            # Rozpocznij nową grę jeśli nie ma aktywnej
            if not self.game.player:
                self.game.new_game("Bohater")
                
        # Wyświetl początkowy opis
        self.show_initial_description()

    def setup_window(self):
        """Inicjalizacja głównego okna z nowoczesnym wyglądem."""
        self.root = tk.Tk()
        self.root.title("Fantasy RPG")
        self.root.geometry("1200x800")
        
        # Ustawienie ciemnego motywu
        self.root.configure(bg='#1E1E1E')
        
        # Konfiguracja skalowania
        self.root.grid_rowconfigure(0, weight=1)
        self.root.grid_columnconfigure(0, weight=1)

    def setup_styles(self):
        """Konfiguracja stylów dla nowoczesnego wyglądu."""
        style = ttk.Style()
        style.theme_use('default')
        
        # Konfiguracja czcionek
        default_font = font.nametofont("TkDefaultFont")
        default_font.configure(size=10, family="Segoe UI")
        
        # Style dla przycisków
        style.configure('Modern.TButton',
            padding=10,
            background='#2D2D2D',
            foreground='white',
            font=('Segoe UI', 10))
            
        # Style dla ramek
        style.configure('Modern.TFrame',
            background='#1E1E1E')
            
        style.configure('Dark.TLabelframe',
            background='#2D2D2D',
            foreground='white')
            
        style.configure('Dark.TLabelframe.Label',
            background='#2D2D2D',
            foreground='white',
            font=('Segoe UI', 11, 'bold'))
        
    def setup_widgets(self):
        """Tworzenie i rozmieszczanie widgetów."""
        # Główny kontener
        self.main_container = ttk.Frame(self.root, style='Modern.TFrame')
        self.main_container.grid(row=0, column=0, sticky="nsew", padx=10, pady=5)
        self.main_container.grid_rowconfigure(0, weight=1)
        self.main_container.grid_columnconfigure(1, weight=3)

        # Panel statystyk (lewy)
        self.stats_frame = ttk.LabelFrame(
            self.main_container,
            text="Status Postaci",
            style='Dark.TLabelframe'
        )
        self.stats_frame.grid(row=0, column=0, sticky="nsew", padx=5)
        
        # Panel gry (środkowy)
        self.game_frame = ttk.LabelFrame(
            self.main_container, 
            text="Świat Gry", 
            style='Dark.TLabelframe'
        )
        self.game_frame.grid(row=0, column=1, sticky="nsew", padx=5)
        self.game_frame.grid_rowconfigure(0, weight=1)
        self.game_frame.grid_columnconfigure(0, weight=1)

        # Obszar tekstu gry z ulepszoną czcionką i kolorami
        self.game_text = scrolledtext.ScrolledText(
            self.game_frame,
            wrap=tk.WORD,
            bg='#1E1E1E',
            fg='#E0E0E0',
            font=('Consolas', 11),
            insertbackground='white',
            selectbackground='#404040',
            selectforeground='white'
        )
        self.game_text.grid(row=0, column=0, sticky="nsew", padx=5, pady=5)

        # Panel komend (prawy)
        self.commands_frame = ttk.LabelFrame(
            self.main_container,
            text="Akcje",
            style='Dark.TLabelframe'
        )
        self.commands_frame.grid(row=0, column=2, sticky="nsew", padx=5)

        # Panel wprowadzania
        self.input_frame = ttk.Frame(self.main_container, style='Modern.TFrame')
        self.input_frame.grid(row=1, column=0, columnspan=3, sticky="ew", pady=5)
        self.input_frame.grid_columnconfigure(0, weight=1)

        # Pole wprowadzania z ulepszoną stylistyką
        self.input_entry = ttk.Entry(
            self.input_frame,
            font=('Consolas', 11),
            style='Modern.TEntry'
        )
        self.input_entry.grid(row=0, column=0, sticky="ew", padx=(0, 5))
        
        # Przycisk wysyłania
        self.send_button = ttk.Button(
            self.input_frame,
            text="Wyślij",
            style='Modern.TButton',
            command=self.handle_input
        )
        self.send_button.grid(row=0, column=1)
        
    def setup_command_buttons(self):
        """Tworzenie przycisków komend z ikonami."""
        # Podstawowe komendy
        basic_commands_frame = ttk.LabelFrame(
            self.commands_frame,
            text="Podstawowe Akcje",
            style='Dark.TLabelframe'
        )
        basic_commands_frame.pack(fill=tk.X, padx=5, pady=5)

        base_commands = {
            "rozejrzyj się": "👀 Rozejrzyj się",
            "ekwipunek": "🎒 Ekwipunek",
            "status": "📊 Status",
            "handel": "💰 Handluj",
            "questy": "📜 Questy",
            "pomoc": "❓ Pomoc"
        }

        for cmd, label in base_commands.items():
            btn = ttk.Button(
                basic_commands_frame,
                text=label,
                style='Modern.TButton',
                command=partial(self.execute_command, cmd)
            )
            btn.pack(fill=tk.X, padx=2, pady=2)

        # Komendy z parametrami
        param_commands_frame = ttk.LabelFrame(
            self.commands_frame,
            text="Akcje Zaawansowane",
            style='Dark.TLabelframe'
        )
        param_commands_frame.pack(fill=tk.X, padx=5, pady=5)

        param_commands = {
            "idź": "🚶 Idź do...",
            "porozmawiaj z": "💬 Porozmawiaj...",
            "atakuj": "⚔️ Atakuj...",
            "podnieś": "⬆️ Podnieś...",
            "użyj": "🔨 Użyj..."
        }

        for cmd, label in param_commands.items():
            btn = ttk.Button(
                param_commands_frame,
                text=label,
                style='Modern.TButton',
                command=partial(self.prompt_parameter, cmd)
            )
            btn.pack(fill=tk.X, padx=2, pady=2)

        # Panel statystyk
        self.setup_stats_panel()
        
    def handle_input(self):
        """Obsługuje wprowadzanie komend przez użytkownika."""
        command = self.input_entry.get().strip()
        if command:
            self.game_text.config(state='normal')
            self.game_text.insert(tk.END, f"\n> {command}\n", 'command')
            
            # Przekazanie komendy do silnika gry
            result = self.game.handle_command(command)
            
            # Wyświetlenie rezultatu
            if result:
                self.game_text.insert(tk.END, f"{result}\n")
            
            self.game_text.config(state='disabled')
            self.input_entry.delete(0, tk.END)
            
            # Aktualizacja statystyk
            self.update_stats()
            
            # Przewiń do końca
            self.game_text.see(tk.END)

    def execute_command(self, command):
        """Wykonuje predefiniowaną komendę."""
        if command == "użyj":
            self.prompt_parameter("użyj")
        elif command == "załóż":
            self.prompt_parameter("załóż")
        elif command == "zdejmij":
            self.prompt_parameter("zdejmij")
        
        self.input_entry.delete(0, tk.END)
        self.input_entry.insert(0, command)
        self.handle_input()
        
    def show_initial_description(self):
        """Wyświetla początkowy opis świata."""
        location = self.game.world.get_location(self.game.player.current_location)
        self.game_text.config(state='normal')
        self.game_text.insert(tk.END, f"\nWitaj w {location.name}!\n")
        self.game_text.insert(tk.END, f"{location.description}\n")
        self.game_text.config(state='disabled')

    def prompt_parameter(self, base_command):
        """Wyświetla okno dialogowe do wprowadzenia parametru komendy."""
        dialog = tk.Toplevel(self.root)
        dialog.title("Wprowadź parametr")
        dialog.geometry("300x150")
    
        label = ttk.Label(dialog, text=f"Wprowadź parametr dla komendy '{base_command}':")
        label.pack(pady=10)
    
        entry = ttk.Entry(dialog)
        entry.pack(pady=10)
    
        def submit():
            param = entry.get().strip()
            if param:
                self.input_entry.delete(0, tk.END)
                self.input_entry.insert(0, f"{base_command} {param}")
                self.handle_input()
            dialog.destroy()
    
        button = ttk.Button(dialog, text="OK", command=submit)
        button.pack(pady=10)

    def setup_bindings(self):
        """Konfiguruje powiązania klawiszy."""
        self.input_entry.bind('<Return>', lambda e: self.handle_input())
        self.root.bind('<Control-l>', lambda e: self.game_text.delete(1.0, tk.END))
        
    def setup_stats_panel(self):
        """Tworzenie panelu statystyk z paskami postępu."""
        self.stats_labels = {}
        
        if not self.game.player:
            logger.error("Nie można utworzyć panelu statystyk - brak gracza")
            return
            
        # Tworzenie statystyk z paskami postępu
        stats = [
            ("Gracz", self.game.player.name),
            ("Poziom", f"{self.game.player.level}"),
            ("Exp", self.create_progress_bar("exp")),
            ("Zdrowie", self.create_progress_bar("health")),
            ("Siła", f"{self.game.player.stats.strength}"),
            ("Obrona", f"{self.game.player.stats.defense}"),
            ("Złoto", f"{self.game.player.gold}")
        ]

        for label, value in stats:
            frame = ttk.Frame(self.stats_frame, style='Modern.TFrame')
            frame.pack(fill=tk.X, padx=5, pady=2)
            
            ttk.Label(
                frame,
                text=label + ":",
                style='Dark.TLabelframe.Label'
            ).pack(side=tk.LEFT, padx=5)
            
            if isinstance(value, tk.Widget):
                value.pack(side=tk.RIGHT, padx=5, fill=tk.X, expand=True)
                self.stats_labels[label] = value
            else:
                value_label = ttk.Label(
                    frame,
                    text=value,
                    style='Dark.TLabelframe.Label'
                )
                value_label.pack(side=tk.RIGHT, padx=5)
                self.stats_labels[label] = value_label

    def create_progress_bar(self, stat_type):
        """Tworzy pasek postępu dla danej statystyki."""
        if stat_type == "exp":
            next_level = self.game.player.experience_to_next_level
            value = (self.game.player.experience / next_level) * 100
            max_value = 100
        elif stat_type == "health":
            value = (self.game.player.stats.health / self.game.player.stats.max_health) * 100
            max_value = 100
        else:
            value = 0
            max_value = 100
            
        progress_bar = ttk.Progressbar(self.stats_frame, length=150, maximum=max_value, value=value)
        return progress_bar
    
    def create_command_buttons(self):
        """Tworzy przyciski komend."""
        commands = [
            ("Status", "status"),
            ("Ekwipunek", "ekwipunek"),
            ("Questy", "questy"),
            ("Rozejrzyj się", "rozejrzyj się")
        ]
        
        for label, command in commands:
            btn = ttk.Button(
                self.command_frame,
                text=label,
                command=lambda cmd=command: self.execute_command(cmd)
            )
            btn.pack(fill=tk.X, padx=5, pady=2)

    def update_stats(self):
        """Aktualizacja wyświetlanych statystyk."""
        self.stats_labels['Poziom'].config(text=f"{self.game.player.level}")
        self.stats_labels['Exp'].config(
            value=(self.game.player.experience / (self.game.player.level * 100)) * 100
        )
        stats = {
            "Poziom": f"{self.game.player.level}",
            "Exp": (self.game.player.experience / (self.game.player.level * 100)) * 100,
            "Zdrowie": (self.game.player.stats.health / self.game.player.stats.max_health) * 100,
            "Siła": f"{self.game.player.stats.strength}",
            "Obrona": f"{self.game.player.stats.defense}",
            "Zręczność": f"{self.game.player.stats.agility}",
            "Inteligencja": f"{self.game.player.stats.intelligence}",
            "Stamina": f"{self.game.player.stats.stamina}/{self.game.player.stats.max_stamina}",
            "Mana": f"{self.game.player.stats.mana}/{self.game.player.stats.max_mana}",
            "Złoto": f"{self.game.player.gold}"
        }
        
        for stat, value in stats.items():
            if stat in self.stats_labels:
                if isinstance(self.stats_labels[stat], ttk.Progressbar):
                    self.stats_labels[stat]['value'] = value
                else:
                    self.stats_labels[stat].configure(text=value)

    def setup_output_redirect(self):
        """Przekierowanie wyjścia do okna gry z kolorami."""
        class TextRedirector:
            def __init__(self, widget, color=None):
                self.widget = widget
                self.color = color

            def write(self, str):
                if self.color:
                    self.widget.insert(tk.END, str, self.color)
                else:
                    self.widget.insert(tk.END, str)
                self.widget.see(tk.END)
            
            def flush(self):
                pass

        sys.stdout = TextRedirector(self.game_text)

    def start(self):
        """Uruchamia interfejs graficzny."""
        self.root.mainloop()

def main():
    """Funkcja główna uruchamiająca grę."""
    game = GameEngine()
    gui = ModernGameGUI(game)
    print("Witaj w Fantasy RPG!")
    game.player.look_around(game.world, game.character_manager)
    gui.start()

if __name__ == "__main__":
    main()Plik: ./interface.py
# interface.py

import os
import time
import logging
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass
from enum import Enum
from colorama import init, Fore, Back, Style
import tkinter as tk
from tkinter import ttk, messagebox

from config import game_config
from exceptions import GameError

logger = logging.getLogger(__name__)
init(autoreset=True)  # Inicjalizacja colorama

class MessageType(Enum):
    """Typy komunikatów w grze."""
    INFO = 'info'
    SUCCESS = 'success'
    WARNING = 'warning'
    ERROR = 'error'
    SYSTEM = 'system'
    COMBAT = 'combat'
    QUEST = 'quest'
    DIALOG = 'dialog'
    ITEM = 'item'
    SKILL = 'skill'
    ACHIEVEMENT = 'achievement'

@dataclass
class DisplayConfig:
    """Konfiguracja wyświetlania."""
    colors: Dict[str, str]
    symbols: Dict[str, str]
    formatting: Dict[str, str]
    animations: Dict[str, bool]

class GameInterface:
    """Główny interfejs gry."""
    
    def __init__(self):
        self.display_config = self._load_display_config()
        self.terminal_width = os.get_terminal_size().columns
        self.last_message = ""
        self.message_history: List[Tuple[str, MessageType]] = []
        self.animation_enabled = game_config.get('gui.animations_enabled', True)
        self.color_enabled = game_config.get('gui.colors_enabled', True)
        self.debug_mode = game_config.get('game_settings.debug_mode', False)
        
        # Cache dla elementów interfejsu
        self._status_cache = {}
        self._location_cache = {}
        self._combat_cache = {}
        
        # Inicjalizacja kolorów i stylów
        self._init_styles()

    def _load_display_config(self) -> DisplayConfig:
        """Ładuje konfigurację wyświetlania."""
        return DisplayConfig(
            colors={
                'primary': Fore.CYAN,
                'secondary': Fore.YELLOW,
                'success': Fore.GREEN,
                'warning': Fore.YELLOW,
                'error': Fore.RED,
                'health': Fore.RED,
                'mana': Fore.BLUE,
                'stamina': Fore.GREEN,
                'exp': Fore.CYAN,
                'gold': Fore.YELLOW,
                'item_common': Fore.WHITE,
                'item_rare': Fore.BLUE,
                'item_epic': Fore.MAGENTA,
                'item_legendary': Fore.YELLOW
            },
            symbols={
                'health': '❤',
                'mana': '⚡',
                'stamina': '⚡',
                'gold': '⚜',
                'exp': '✧',
                'arrow': '→',
                'checkmark': '✓',
                'cross': '✗',
                'star': '★',
                'bullet': '•'
            },
            formatting={
                'header': Style.BRIGHT,
                'subheader': Style.DIM,
                'important': Style.BRIGHT + Fore.YELLOW,
                'highlight': Back.WHITE + Fore.BLACK
            },
            animations={
                'typing': True,
                'loading': True,
                'combat': True,
                'transitions': True
            }
        )

    def _init_styles(self):
        """Inicjalizuje style dla różnych typów komunikatów."""
        self.message_styles = {
            MessageType.INFO: self.display_config.colors['primary'],
            MessageType.SUCCESS: self.display_config.colors['success'],
            MessageType.WARNING: self.display_config.colors['warning'],
            MessageType.ERROR: self.display_config.colors['error'],
            MessageType.SYSTEM: Style.DIM + Fore.WHITE,
            MessageType.COMBAT: self.display_config.colors['health'],
            MessageType.QUEST: self.display_config.colors['primary'],
            MessageType.DIALOG: self.display_config.colors['secondary'],
            MessageType.ITEM: self.display_config.colors['item_common'],
            MessageType.SKILL: self.display_config.colors['mana'],
            MessageType.ACHIEVEMENT: self.display_config.colors['gold']
        }

    def clear_screen(self):
        """Czyści ekran terminala."""
        os.system('cls' if os.name == 'nt' else 'clear')

    def show_message(self, message: str, message_type: MessageType = MessageType.INFO):
        """Wyświetla sformatowany komunikat."""
        style = self.message_styles.get(message_type, '')
        formatted_message = f"{style}{message}{Style.RESET_ALL}"
        
        print(formatted_message)
        self.last_message = message
        self.message_history.append((message, message_type))
        
        # Ogranicz historię komunikatów
        if len(self.message_history) > 100:
            self.message_history.pop(0)

    def animate_text(self, text: str, delay: float = 0.03):
        """Wyświetla tekst z animacją."""
        if not self.animation_enabled:
            print(text)
            return
            
        for char in text:
            print(char, end='', flush=True)
            time.sleep(delay)
        print()

    def draw_progress_bar(self, value: float, max_value: float, width: int = 20, 
                         color: str = None, show_percentage: bool = True) -> str:
        """Rysuje pasek postępu."""
        percentage = min(100, (value / max_value) * 100)
        filled_width = int(width * percentage / 100)
        empty_width = width - filled_width
        
        bar_color = color or self.display_config.colors['primary']
        
        bar = (
            f"{bar_color}"
            f"{'█' * filled_width}{'░' * empty_width}"
            f"{Style.RESET_ALL}"
        )
        
        if show_percentage:
            bar += f" {percentage:>3.0f}%"
            
        return bar

    def draw_separator(self, char: str = "=", color: str = None):
        """Rysuje separator na całą szerokość terminala."""
        color = color or self.display_config.colors['primary']
        print(f"{color}{char * self.terminal_width}{Style.RESET_ALL}")

    def center_text(self, text: str, width: int = None) -> str:
        """Centruje tekst."""
        width = width or self.terminal_width
        return text.center(width)

    def format_table(self, headers: List[str], rows: List[List[str]], 
                    colors: List[str] = None) -> str:
        """Formatuje dane w formie tabeli."""
        if not rows:
            return ""
            
        # Oblicz szerokość kolumn
        col_widths = [len(h) for h in headers]
        for row in rows:
            for i, cell in enumerate(row):
                col_widths[i] = max(col_widths[i], len(str(cell)))
                
        # Utwórz separator
        separator = "+" + "+".join("-" * (w + 2) for w in col_widths) + "+"
        
        # Formatuj nagłówki
        header_row = "|" + "|".join(
            f" {h:<{w}} " for h, w in zip(headers, col_widths)
        ) + "|"
        
        # Formatuj wiersze
        table_rows = []
        for row in rows:
            colored_row = []
            for i, cell in enumerate(row):
                color = colors[i] if colors and i < len(colors) else ""
                reset = Style.RESET_ALL if color else ""
                colored_row.append(f"{color}{str(cell):<{col_widths[i]}}{reset}")
            table_rows.append(
                "|" + "|".join(f" {cell} " for cell in colored_row) + "|"
            )
            
        # Złącz wszystko
        return "\n".join([
            separator,
            header_row,
            separator,
            *table_rows,
            separator
        ])

    def show_error(self, error: Exception):
        """Wyświetla błąd w przyjazny dla użytkownika sposób."""
        if isinstance(error, GameError):
            self.show_message(str(error), MessageType.ERROR)
        else:
            if self.debug_mode:
                logger.exception("Wystąpił nieoczekiwany błąd:")
            self.show_message(
                "Wystąpił nieoczekiwany błąd podczas wykonywania operacji.", 
                MessageType.ERROR
            )

    def get_input(self, prompt: str = "> ", validation_func = None) -> str:
        """Pobiera dane wejściowe od użytkownika z opcjonalną walidacją."""
        while True:
            try:
                user_input = input(f"{self.display_config.colors['secondary']}{prompt}{Style.RESET_ALL}")
                if validation_func:
                    result = validation_func(user_input)
                    if result is True:
                        return user_input
                    elif isinstance(result, str):
                        self.show_message(result, MessageType.ERROR)
                        continue
                return user_input
            except KeyboardInterrupt:
                print("\n")
                return ""
            except Exception as e:
                self.show_message(
                    "Wystąpił błąd podczas wprowadzania danych.", 
                    MessageType.ERROR
                )
                if self.debug_mode:
                    logger.exception("Błąd wprowadzania:")
                    
    # Kontynuacja klasy GameInterface

    def show_game_status(self, player, world):
        """Wyświetla aktualny stan gry."""
        self.clear_screen()
        self.draw_separator()
        print(self.center_text("STATUS GRY", self.terminal_width))
        self.draw_separator()
        
        # Status gracza
        print(f"\n{self.display_config.colors['primary']}Status Postaci:{Style.RESET_ALL}")
        print(f"Imię: {player.name}")
        print(f"Poziom: {player.level} ({player.experience}/{player.experience_to_next_level} EXP)")
        
        # Paski zdrowia, many i staminy
        health_bar = self.draw_progress_bar(
            player.stats.health, 
            player.stats.max_health,
            color=self.display_config.colors['health']
        )
        mana_bar = self.draw_progress_bar(
            player.stats.mana,
            player.stats.max_mana,
            color=self.display_config.colors['mana']
        )
        stamina_bar = self.draw_progress_bar(
            player.stats.stamina,
            player.stats.max_stamina,
            color=self.display_config.colors['stamina']
        )
        
        print(f"{self.display_config.symbols['health']} Zdrowie: {health_bar}")
        print(f"{self.display_config.symbols['mana']} Mana: {mana_bar}")
        print(f"{self.display_config.symbols['stamina']} Stamina: {stamina_bar}")
        
        # Podstawowe statystyki
        print("\nStatystyki:")
        stats = [
            (f"{self.display_config.colors['primary']}Siła:{Style.RESET_ALL}", player.stats.strength),
            (f"{self.display_config.colors['primary']}Obrona:{Style.RESET_ALL}", player.stats.defense),
            (f"{self.display_config.colors['primary']}Zręczność:{Style.RESET_ALL}", player.stats.agility),
            (f"{self.display_config.colors['primary']}Inteligencja:{Style.RESET_ALL}", player.stats.intelligence)
        ]
        
        for stat, value in stats:
            print(f"{stat} {value}")
            
        # Złoto i ekwipunek
        print(f"\n{self.display_config.symbols['gold']} Złoto: {player.gold}")
        print(f"Ekwipunek: {len(player.inventory.items)}/{player.inventory.capacity}")
        
        # Aktualna lokacja
        location = world.get_location(player.current_location)
        print(f"\n{self.display_config.colors['secondary']}Obecna lokacja:{Style.RESET_ALL} {location.name}")
        
        if location.weather:
            print(f"Pogoda: {location.weather.description}")
            
        # Aktywne efekty
        if player.status_effects:
            print("\nAktywne efekty:")
            for effect in player.status_effects:
                duration = f"({effect.duration}t)" if effect.duration > 0 else "(stały)"
                print(f"- {effect.name} {duration}")

    def show_combat_interface(self, player, enemy, combat_manager):
        """Wyświetla interfejs walki."""
        self.clear_screen()
        self.draw_separator(char="═")
        print(self.center_text(f"WALKA: {player.name} vs {enemy.name}"))
        self.draw_separator(char="═")
        
        # Status gracza
        print(f"\n{self.display_config.colors['primary']}Twój status:{Style.RESET_ALL}")
        player_health = self.draw_progress_bar(
            player.stats.health,
            player.stats.max_health,
            color=self.display_config.colors['health']
        )
        player_stamina = self.draw_progress_bar(
            combat_manager.player_status['stamina'],
            100,
            color=self.display_config.colors['stamina']
        )
        
        print(f"HP: {player_health}")
        print(f"Stamina: {player_stamina}")
        
        # Status przeciwnika
        print(f"\n{self.display_config.colors['error']}Przeciwnik:{Style.RESET_ALL}")
        enemy_health = self.draw_progress_bar(
            enemy.stats.health,
            enemy.stats.max_health,
            color=self.display_config.colors['health']
        )
        print(f"{enemy.name}: {enemy_health}")
        
        # Dostępne akcje
        print("\nDostępne akcje:")
        actions = [
            "1. Atak podstawowy",
            "2. Użyj przedmiotu",
            "3. Użyj umiejętności",
            "4. Przyjmij postawę obronną",
            "5. Spróbuj uciec"
        ]
        
        for action in actions:
            print(action)
            
        # Dziennik walki
        if combat_manager.combat_log:
            print(f"\n{self.display_config.colors['secondary']}Przebieg walki:{Style.RESET_ALL}")
            for message, msg_type in combat_manager.combat_log[-3:]:
                self.show_message(message, msg_type)
                
    def show_status(self, player):
        """Wyświetla status gracza."""
        print(f"\n=== Status Postaci ===")
        print(f"Imię: {player.name}")
        print(f"Poziom: {player.level}")
        print(f"Doświadczenie: {player.experience}/{player.experience_to_next_level}")
        print(f"Zdrowie: {player.stats.health}/{player.stats.max_health}")
        print(f"Siła: {player.stats.strength}")
        print(f"Obrona: {player.stats.defense}")
        print(f"Złoto: {player.gold}")
        
        if player.equipment_slots:
            print("\nWyposażenie:")
            for slot, item_id in player.equipment_slots.items():
                if item_id:
                    item = player.inventory.item_manager.get_item(item_id)
                    print(f"{slot}: {item.name}")
                else:
                    print(f"{slot}: Puste")

    def show_inventory(self, player):
        """Wyświetla ekwipunek gracza."""
        self.clear_screen()
        print(f"\n{self.display_config.colors['primary']}=== EKWIPUNEK ==={Style.RESET_ALL}")
        
        # Założone przedmioty
        print("\nZałożone przedmioty:")
        for slot, item_id in player.equipment_slots.items():
            if item_id:
                item = player.inventory.item_manager.get_item(item_id)
                print(f"{slot}: {self._format_item_name(item)}")
            else:
                print(f"{slot}: {self.display_config.colors['secondary']}pusty{Style.RESET_ALL}")
                
        """Wyświetla ekwipunek gracza."""
        print("\n=== Ekwipunek ===")
        if not player.inventory.items:
            print("Ekwipunek jest pusty!")
            return

        for item_id, quantity in player.inventory.items.items():
            item = player.inventory.item_manager.get_item(item_id)
            print(f"- {item.name} x{quantity}: {item.description}")
                
        # Lista przedmiotów
        print("\nPrzedmioty:")
        if not player.inventory.items:
            print("Ekwipunek jest pusty!")
        else:
            items_table = []
            for item_id, quantity in player.inventory.items.items():
                item = player.inventory.item_manager.get_item(item_id)
                equipped = "*" if item_id in player.equipment_slots.values() else ""
                items_table.append([
                    f"{self._format_item_name(item)}{equipped}",
                    str(quantity),
                    item.type,
                    item.description
                ])
            
            headers = ["Przedmiot", "Ilość", "Typ", "Opis"]
            print(self.format_table(headers, items_table))
            
        print(f"\nPojemność: {len(player.inventory.items)}/{player.inventory.capacity}")
        
        
    def handle_command(self, command: str, game_state):
        """Obsługa komend gracza."""
        if command == "status":
            self.show_status(game_state.player)
        elif command == "ekwipunek":
            self.show_inventory(game_state.player)
        elif command == "questy":
            self.show_quests(game_state.player)
        elif command == "rozejrzyj się":
            location = game_state.world.get_location(game_state.player.current_location)
            print(f"\n=== {location.name} ===")
            print(location.description)
            if location.npcs:
                print("\nPostacie w pobliżu:")
                for npc_id in location.npcs:
                    npc = game_state.character_manager.get_character(npc_id)
                    print(f"- {npc.name}")
        else:
            print("Nieznana komenda!")
            
    def show_quests(self, player):
        """Wyświetla aktywne zadania."""
        print("\n=== Aktywne Questy ===")
        if not player.active_quests:
            print("Nie masz aktywnych zadań!")
            return

        for quest in player.active_quests:
            print(f"\n- {quest.name}")
            print(f"  Opis: {quest.description}")
            current_stage = quest.get_current_stage()
            print(f"  Aktualny cel: {current_stage['description']}")

    def _format_item_name(self, item) -> str:
        """Formatuje nazwę przedmiotu z odpowiednim kolorem."""
        rarity_colors = {
            'common': self.display_config.colors['item_common'],
            'rare': self.display_config.colors['item_rare'],
            'epic': self.display_config.colors['item_epic'],
            'legendary': self.display_config.colors['item_legendary']
        }
        color = rarity_colors.get(item.rarity, self.display_config.colors['item_common'])
        return f"{color}{item.name}{Style.RESET_ALL}"

    def show_trade_interface(self, merchant, player):
        """Wyświetla interfejs handlu."""
        self.clear_screen()
        print(f"\n{self.display_config.colors['primary']}=== HANDEL z {merchant.name} ==={Style.RESET_ALL}")
        print(f"\nTwoje złoto: {self.display_config.colors['gold']}{player.gold}{Style.RESET_ALL}")
        
        # Towary kupca
        print("\nDostępne towary:")
        merchant_items = []
        for item_id in merchant.inventory:
            item = player.inventory.item_manager.get_item(item_id)
            price = merchant.get_sell_price(item_id)
            can_afford = price <= player.gold
            price_color = self.display_config.colors['success'] if can_afford else self.display_config.colors['error']
            
            merchant_items.append([
                self._format_item_name(item),
                f"{price_color}{price}{Style.RESET_ALL}",
                item.description
            ])
            
        if merchant_items:
            headers = ["Przedmiot", "Cena", "Opis"]
            print(self.format_table(headers, merchant_items))
        else:
            print("Kupiec nie ma obecnie żadnych towarów.")
            
        # Opcje handlu
        print("\nOpcje:")
        print("1. Kup przedmiot")
        print("2. Sprzedaj przedmiot")
        print("3. Zakończ handel")

    def show_quest_log(self, player):
        """Wyświetla dziennik zadań."""
        self.clear_screen()
        print(f"\n{self.display_config.colors['primary']}=== DZIENNIK ZADAŃ ==={Style.RESET_ALL}")
        
        # Aktywne questy
        if player.active_quests:
            print(f"\n{self.display_config.colors['secondary']}Aktywne zadania:{Style.RESET_ALL}")
            for quest in player.active_quests:
                current_stage = quest.get_current_stage()
                progress = self.draw_progress_bar(
                    quest.current_stage,
                    len(quest.stages),
                    width=10,
                    show_percentage=False
                )
                print(f"\n- {quest.name} {progress}")
                print(f"  Cel: {current_stage['description']}")
                
                # Pokaż nagrody
                if quest.rewards:
                    print("  Nagrody:")
                    self._display_rewards(quest.rewards)
        else:
            print("\nNie masz aktywnych zadań.")
            
        # Ukończone questy
        if player.completed_quests:
            print(f"\n{self.display_config.colors['success']}Ukończone zadania:{Style.RESET_ALL}")
            for quest in player.completed_quests:
                print(f"- {quest.name} {self.display_config.symbols['checkmark']}")

    def _display_rewards(self, rewards: dict):
        """Wyświetla nagrody questa."""
        for reward_type, value in rewards.items():
            if reward_type == 'gold':
                print(f"  {self.display_config.symbols['gold']} {value} złota")
            elif reward_type == 'exp':
                print(f"  {self.display_config.symbols['exp']} {value} doświadczenia")
            elif reward_type == 'items':
                for item_id, quantity in value.items():
                    item = self.item_manager.get_item(item_id)
                    print(f"  - {self._format_item_name(item)} x{quantity}")
            elif reward_type == 'reputation':
                for faction, amount in value.items():
                    sign = '+' if amount > 0 else ''
                    print(f"  - Reputacja z {faction}: {sign}{amount}")
                    
    # Kontynuacja klasy GameInterface

    def show_dialog_interface(self, npc, player, dialog_manager):
        """Wyświetla interfejs dialogowy."""
        self.clear_screen()
        print(f"\n{self.display_config.colors['secondary']}=== Rozmowa z {npc.name} ==={Style.RESET_ALL}")
        
        # Wyświetl portret/opis NPC
        if hasattr(npc, 'description'):
            print(f"\n{npc.description}")
            
        # Sprawdź nastawienie NPC na podstawie reputacji
        if hasattr(npc, 'faction') and npc.faction in player.reputation:
            reputation = player.reputation[npc.faction]
            attitude = self._get_npc_attitude(reputation)
            print(f"Nastawienie: {attitude}")
            
        # Wyświetl aktualną wypowiedź
        current_dialog = dialog_manager.get_current_dialog()
        if current_dialog:
            print(f"\n{self.display_config.colors['dialog']}\"{current_dialog.text}\"{Style.RESET_ALL}")
            
            # Wyświetl dostępne opcje
            if current_dialog.options:
                print("\nDostępne odpowiedzi:")
                for i, option in enumerate(current_dialog.options, 1):
                    if self._check_dialog_option_requirements(option, player):
                        print(f"{i}. {option.text}")
                    else:
                        print(f"{self.display_config.colors['error']}{i}. {option.text} "
                              f"(Wymagania niespełnione){Style.RESET_ALL}")
                              
        print("\n0. Zakończ rozmowę")

    def _get_npc_attitude(self, reputation: int) -> str:
        """Zwraca tekstowy opis nastawienia NPC na podstawie reputacji."""
        attitudes = [
            (90, f"{self.display_config.colors['success']}Uwielbia cię{Style.RESET_ALL}"),
            (70, f"{self.display_config.colors['success']}Przyjazny{Style.RESET_ALL}"),
            (30, f"{self.display_config.colors['secondary']}Neutralny{Style.RESET_ALL}"),
            (-30, f"{self.display_config.colors['warning']}Nieufny{Style.RESET_ALL}"),
            (-70, f"{self.display_config.colors['error']}Wrogi{Style.RESET_ALL}"),
            (-100, f"{self.display_config.colors['error']}Nienawidzi cię{Style.RESET_ALL}")
        ]
        
        for threshold, attitude in attitudes:
            if reputation >= threshold:
                return attitude
        return attitudes[-1][1]

    def _check_dialog_option_requirements(self, option, player) -> bool:
        """Sprawdza czy gracz spełnia wymagania opcji dialogowej."""
        if not hasattr(option, 'requirements'):
            return True
            
        for req_type, req_value in option.requirements.items():
            if req_type == 'level' and player.level < req_value:
                return False
            elif req_type == 'reputation':
                for faction, value in req_value.items():
                    if player.reputation.get(faction, 0) < value:
                        return False
            elif req_type == 'items':
                for item_id, quantity in req_value.items():
                    if not player.inventory.has_item(item_id, quantity):
                        return False
            elif req_type == 'skills':
                for skill, level in req_value.items():
                    if player.get_skill_level(skill) < level:
                        return False
        return True

    def show_main_menu(self):
        """Wyświetla główne menu gry."""
        self.clear_screen()
        self._show_game_logo()
        
        options = [
            ("Nowa Gra", "Rozpocznij nową przygodę"),
            ("Wczytaj Grę", "Kontynuuj poprzednią rozgrywkę"),
            ("Opcje", "Zmień ustawienia gry"),
            ("Twórcy", "Zobacz informacje o twórcach"),
            ("Wyjście", "Zakończ grę")
        ]
        
        for i, (option, desc) in enumerate(options, 1):
            print(f"\n{i}. {self.display_config.colors['primary']}{option}{Style.RESET_ALL}")
            print(f"   {self.display_config.colors['secondary']}{desc}{Style.RESET_ALL}")

    def _show_game_logo(self):
        """Wyświetla logo gry w ASCII art."""
        # Tu możesz dodać swoje logo w ASCII art
        logo = """
        ╔═══════════════════════════════════════╗
        ║             Fantasy RPG               ║
        ╚═══════════════════════════════════════╝
        """
        print(f"{self.display_config.colors['primary']}{logo}{Style.RESET_ALL}")

    def show_notification(self, message: str, notification_type: MessageType,
                        duration: float = 3.0, sound: bool = True):
        """Wyświetla powiadomienie."""
        color = self.message_styles.get(notification_type, '')
        
        # Określ symbol na podstawie typu
        symbols = {
            MessageType.SUCCESS: self.display_config.symbols['checkmark'],
            MessageType.WARNING: '!',
            MessageType.ERROR: self.display_config.symbols['cross'],
            MessageType.ACHIEVEMENT: self.display_config.symbols['star'],
            MessageType.QUEST: '!',
            MessageType.ITEM: '+'
        }
        symbol = symbols.get(notification_type, '')
        
        # Sformatuj powiadomienie
        notification = f"\n{color}{symbol} {message}{Style.RESET_ALL}"
        
        # Wyświetl powiadomienie z animacją
        if self.animation_enabled:
            self._animate_notification(notification, duration)
        else:
            print(notification)
            
        # Odtwórz dźwięk jeśli włączony
        if sound and game_config.get('gui.sound_enabled', True):
            self._play_notification_sound(notification_type)

    def _animate_notification(self, notification: str, duration: float):
        """Animuje pojawienie się i zniknięcie powiadomienia."""
        print(notification, end='', flush=True)
        time.sleep(duration)
        print('\r' + ' ' * len(notification) + '\r', end='', flush=True)

    def _play_notification_sound(self, notification_type: MessageType):
        """Odtwarza dźwięk powiadomienia."""
        # Tu możesz dodać obsługę dźwięków
        pass

    def show_achievement_popup(self, achievement: dict):
        """Wyświetla popup o odblokowaniu osiągnięcia."""
        self.show_notification(
            f"Osiągnięcie odblokowane: {achievement['name']}!",
            MessageType.ACHIEVEMENT,
            duration=5.0
        )
        
        # Szczegóły osiągnięcia
        print(f"\n{self.display_config.colors['gold']}Nowe osiągnięcie!{Style.RESET_ALL}")
        print(f"{achievement['name']}")
        print(f"{self.display_config.colors['secondary']}{achievement['description']}{Style.RESET_ALL}")
        
        # Pokaż nagrody
        if 'rewards' in achievement:
            print("\nNagrody:")
            self._display_rewards(achievement['rewards'])

    def show_loading_screen(self, message: str = "Wczytywanie..."):
        """Wyświetla ekran ładowania."""
        if not self.animation_enabled:
            print(message)
            return
            
        frames = ['⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏']
        
        for _ in range(20):  # Animacja przez 20 klatek
            for frame in frames:
                print(f'\r{frame} {message}', end='', flush=True)
                time.sleep(0.1)

    def show_options_menu(self, current_settings: dict):
        """Wyświetla menu opcji."""
        self.clear_screen()
        print(f"\n{self.display_config.colors['primary']}=== OPCJE ==={Style.RESET_ALL}")
        
        options = [
            ('Dźwięki', 'sound_enabled', 'bool'),
            ('Muzyka', 'music_enabled', 'bool'),
            ('Animacje', 'animations_enabled', 'bool'),
            ('Kolory', 'colors_enabled', 'bool'),
            ('Głośność dźwięków', 'sound_volume', 'slider'),
            ('Głośność muzyki', 'music_volume', 'slider'),
            ('Tryb pełnoekranowy', 'fullscreen', 'bool'),
            ('Język', 'language', 'selection', ['pl', 'en']),
            ('Trudność', 'difficulty', 'selection', ['easy', 'normal', 'hard'])
        ]
        
        for i, (name, setting, type_, *args) in enumerate(options, 1):
            current_value = current_settings.get(setting)
            
            if type_ == 'bool':
                value_display = ('Włączone' if current_value else 'Wyłączone')
                color = (self.display_config.colors['success'] if current_value 
                        else self.display_config.colors['error'])
            elif type_ == 'slider':
                value_display = self.draw_progress_bar(
                    current_value * 100, 100, width=10, show_percentage=True
                )
                color = self.display_config.colors['primary']
            elif type_ == 'selection':
                value_display = current_value
                color = self.display_config.colors['secondary']
                
            print(f"{i}. {name}: {color}{value_display}{Style.RESET_ALL}")
            
        print("\n0. Powrót")

    def show_help(self):
        """Wyświetla pomoc dotyczącą sterowania i mechanik gry."""
        self.clear_screen()
        print(f"\n{self.display_config.colors['primary']}=== POMOC ==={Style.RESET_ALL}")
        
        sections = {
            'Podstawowe komendy': {
                'rozejrzyj się': 'Pokazuje opis obecnej lokacji',
                'ekwipunek': 'Zarządzaj ekwipunkiem',
                'status': 'Pokaż statystyki postaci',
                'mapa': 'Otwórz mapę świata'
            },
            'Walka': {
                'atakuj [cel]': 'Rozpocznij walkę',
                'użyj [przedmiot]': 'Użyj przedmiotu',
                'umiejętność [nazwa]': 'Użyj umiejętności specjalnej'
            },
            'Interakcje': {
                'porozmawiaj [postać]': 'Rozpocznij dialog',
                'handluj [kupiec]': 'Rozpocznij handel',
                'podnieś [przedmiot]': 'Podnieś przedmiot'
            },
            'Questy': {
                'questy': 'Pokaż aktywne zadania',
                'przyjmij quest': 'Przyjmij nowe zadanie',
                'porzuć quest': 'Porzuć aktywne zadanie'
            }
        }
        
        for section, commands in sections.items():
            print(f"\n{self.display_config.colors['secondary']}{section}:{Style.RESET_ALL}")
            for command, description in commands.items():
                print(f"  {self.display_config.colors['primary']}{command}{Style.RESET_ALL}")
                print(f"    {description}")
                
        print("\nNaciśnij Enter, aby kontynuować...")
        input()

    def show_credits(self):
        """Wyświetla informacje o twórcach."""
        self.clear_screen()
        self._show_game_logo()
        
        credits = [
            ("Twórca", ["John Doe"]),
            ("Programowanie", ["Jane Smith", "Bob Wilson"]),
            ("Grafika", ["Alice Brown"]),
            ("Muzyka", ["Mike Johnson"]),
            ("Podziękowania", ["Wszystkim testerom i społeczności!"])
        ]
        
        for section, names in credits:
            print(f"\n{self.display_config.colors['primary']}{section}:{Style.RESET_ALL}")
            for name in names:
                self.animate_text(f"  {name}", delay=0.1)
                
        print("\nNaciśnij Enter, aby wrócić...")
        input()Plik: ./inventory.py
# inventory.py
from items import ItemManager

class Inventory:
    def __init__(self, capacity=20):
        self.capacity = capacity
        self.items = {}  # {item_id: quantity}
        self.equipped = {
            'weapon': None, 
            'armor': None
        }
        self.item_manager = None

    def set_item_manager(self, item_manager):
        """Sets the item manager."""
        self.item_manager = item_manager

    def add_item(self, item_id, quantity=1):
        """Adds an item to the inventory."""
        if len(self.items) >= self.capacity and item_id not in self.items:
            return False, "Ekwipunek jest pełny!"

        if item_id in self.items:
            self.items[item_id] += quantity
        else:
            self.items[item_id] = quantity
        
        item = self.item_manager.get_item(item_id)
        return True, f"Dodano {quantity} x {item.name}"

    def remove_item(self, item_id, quantity=1):
        """Removes an item from the inventory."""
        if item_id not in self.items:
            return False, "Nie znaleziono przedmiotu w ekwipunku."
        if self.items[item_id] < quantity:
            return False, "Nie masz wystarczającej ilości tego przedmiotu."
        
        item = self.item_manager.get_item(item_id)
        self.items[item_id] -= quantity
        if self.items[item_id] <= 0:
            del self.items[item_id]
        return True, f"{item.name}"

    def equip_item(self, item_id, player):
        """Ekwipuje przedmiot jako broń lub zbroję."""
        if item_id not in self.items:
            return False, "Nie masz tego przedmiotu!"

        item = self.item_manager.get_item(item_id)
        if item.type not in ["broń", "zbroja"]:
            return False, "Nie możesz założyć tego przedmiotu!"

        slot = "weapon" if item.type == "broń" else "armor"

        # Zdejmij poprzedni przedmiot, jeśli był założony
        if self.equipped[slot]:
            old_item = self.item_manager.get_item(self.equipped[slot])
            if item.type == "broń":
                player.strength -= old_item.properties.get("damage", 0)
            else:
                player.defense -= old_item.properties.get("defense", 0)

        # Załóż nowy przedmiot
        self.equipped[slot] = item_id
        if item.type == "broń":
            player.strength += item.properties.get("damage", 0)
        else:
            player.defense += item.properties.get("defense", 0)

        return True, f"Założono {item.name}!"

    def unequip_item(self, slot, player):
        """Zdejmuje przedmiot z danego slotu."""
        if not self.equipped[slot]:
            return False, f"Nie masz niczego założonego w slocie {slot}!"
        
        item = self.item_manager.get_item(self.equipped[slot])
        if item.type == "broń":
            player.strength -= item.properties.get("damage", 0)
        else:
            player.defense -= item.properties.get("defense", 0)
        
        self.equipped[slot] = None
        return True, f"Zdjęto {item.name}!"

    def show_inventory(self, player=None):
        """Wyświetla zawartość ekwipunku z interaktywnym menu."""
        while True:
            print("\n=== Ekwipunek ===")
            
            # Pokaż założone przedmioty
            print("\nZałożone przedmioty:")
            weapon = self.item_manager.get_item(self.equipped["weapon"]) if self.equipped["weapon"] else None
            armor = self.item_manager.get_item(self.equipped["armor"]) if self.equipped["armor"] else None
            print(f"Broń: {weapon.name if weapon else 'brak'}")
            print(f"Zbroja: {armor.name if armor else 'brak'}")

            # Pokaż przedmioty w ekwipunku
            if not self.items:
                print("\nEkwipunek jest pusty!")
            else:
                print("\nPrzedmioty w ekwipunku:")
                items_list = []  # Lista do numerowania przedmiotów
                for item_id, quantity in self.items.items():
                    item = self.item_manager.get_item(item_id)
                    equipped = ""
                    if item_id == self.equipped.get("weapon") or item_id == self.equipped.get("armor"):
                        equipped = " (założone)"
                    items_list.append((item_id, item, quantity))
                    print(f"{len(items_list)}. {item.name} x{quantity}{equipped}: {item.description}")

            # Menu akcji
            print("\nAkcje:")
            print("1. Załóż przedmiot")
            print("2. Zdejmij przedmiot")
            print("3. Użyj przedmiot")
            print("4. Wyrzuć przedmiot")
            print("5. Powrót")

            choice = input("\nWybierz akcję (1-5): ").strip()

            if choice == "1":  # Załóż przedmiot
                if not self.items:
                    print("Nie masz żadnych przedmiotów do założenia!")
                    continue
                    
                item_num = input("Wybierz numer przedmiotu do założenia (0 aby anulować): ")
                try:
                    item_num = int(item_num)
                    if item_num == 0:
                        continue
                    if 1 <= item_num <= len(items_list):
                        item_id, item, _ = items_list[item_num - 1]
                        if player:
                            success, message = self.equip_item(item_id, player)
                            print(message)
                    else:
                        print("Nieprawidłowy numer przedmiotu!")
                except ValueError:
                    print("Wprowadź poprawną liczbę!")

            elif choice == "2":  # Zdejmij przedmiot
                print("\nKtóry przedmiot chcesz zdjąć?")
                print("1. Broń")
                print("2. Zbroja")
                print("3. Anuluj")
                
                slot_choice = input("Wybierz slot (1-3): ").strip()
                if slot_choice == "1":
                    if player:
                        success, message = self.unequip_item("weapon", player)
                        print(message)
                elif slot_choice == "2":
                    if player:
                        success, message = self.unequip_item("armor", player)
                        print(message)

            elif choice == "3":  # Użyj przedmiot
                if not self.items:
                    print("Nie masz żadnych przedmiotów do użycia!")
                    continue
                    
                item_num = input("Wybierz numer przedmiotu do użycia (0 aby anulować): ")
                try:
                    item_num = int(item_num)
                    if item_num == 0:
                        continue
                    if 1 <= item_num <= len(items_list):
                        item_id, item, _ = items_list[item_num - 1]
                        if player:
                            success, message = self.use_item(item_id, player)
                            print(message)
                    else:
                        print("Nieprawidłowy numer przedmiotu!")
                except ValueError:
                    print("Wprowadź poprawną liczbę!")

            elif choice == "4":  # Wyrzuć przedmiot
                if not self.items:
                    print("Nie masz żadnych przedmiotów do wyrzucenia!")
                    continue
                    
                item_num = input("Wybierz numer przedmiotu do wyrzucenia (0 aby anulować): ")
                try:
                    item_num = int(item_num)
                    if item_num == 0:
                        continue
                    if 1 <= item_num <= len(items_list):
                        item_id, item, quantity = items_list[item_num - 1]
                        if quantity > 1:
                            amount = input(f"Ile sztuk chcesz wyrzucić? (max {quantity}): ")
                            try:
                                amount = int(amount)
                                if 1 <= amount <= quantity:
                                    success, message = self.remove_item(item_id, amount)
                                    print(f"Wyrzucono {amount}x {item.name}")
                                else:
                                    print("Nieprawidłowa ilość!")
                            except ValueError:
                                print("Wprowadź poprawną liczbę!")
                        else:
                            success, message = self.remove_item(item_id)
                            print(f"Wyrzucono {item.name}")
                    else:
                        print("Nieprawidłowy numer przedmiotu!")
                except ValueError:
                    print("Wprowadź poprawną liczbę!")

            elif choice == "5":  # Powrót
                break
            
            else:
                print("Nieprawidłowa opcja!")

    def use_item(self, item_id, player):
        """Używa przedmiotu i aplikuje jego efekty."""
        if item_id not in self.items:
            return False, "Nie masz tego przedmiotu!"

        item = self.item_manager.get_item(item_id)
        if item.type == "konsumpcyjny":
            if "healing" in item.properties:
                healing = item.properties["healing"]
                if player.health == player.max_health:
                    return False, "Masz już pełne zdrowie!"
                player.health = min(player.max_health, player.health + healing)
                success, msg = self.remove_item(item_id)
                if success:
                    return True, f"Użyto {item.name}. Przywrócono {healing} punktów zdrowia."
        return False, "Nie możesz użyć tego przedmiotu!"Plik: ./items.py
import json

class Item:
    def __init__(self, item_id, data):
        self.id = item_id
        self.name = data['name']
        self.description = data['description']
        self.type = data['type']
        # Zapisujemy wszystkie pozostałe właściwości
        self.properties = {k: v for k, v in data.items() 
                         if k not in ['name', 'description', 'type']}
        print(f"DEBUG Item: Utworzono przedmiot: {self.name}, typ: {self.type}, właściwości: {self.properties}")  # Debug

class ItemManager:
    def __init__(self, data_file='data/items.json'):
        self._items = {}  # Słownik przechowujący obiekty Item
        with open(data_file, 'r', encoding='utf-8') as f:
            data = json.load(f)['items']
            for item_id, item_data in data.items():
                self._items[item_id] = Item(item_id, item_data)
                print(f"DEBUG ItemManager: Załadowano przedmiot: {item_id}")  # Debug

    def get_item(self, item_id):
        """Zwraca obiekt przedmiotu na podstawie jego ID."""
        item = self._items.get(item_id)
        print(f"DEBUG ItemManager: Pobrano przedmiot: {item_id}, znaleziono: {item.name if item else None}")  # Debug
        return item

    def get_item_id_by_name(self, item_name):
        """Zwraca ID przedmiotu na podstawie jego nazwy."""
        item_name = item_name.lower().strip()
        print(f"DEBUG ItemManager: Szukam przedmiotu o nazwie: {item_name}")  # Debug
        for item_id, item in self._items.items():
            if item.name.lower().strip() == item_name:
                print(f"DEBUG ItemManager: Znaleziono przedmiot: {item_id}")  # Debug
                return item_id
        print(f"DEBUG ItemManager: Nie znaleziono przedmiotu o nazwie: {item_name}")  # Debug
        return NonePlik: ./main.py
# main.py
import sys
import argparse
import logging
from typing import Optional
import tkinter as tk

from config import game_config
from game import GameEngine
from gui import ModernGameGUI
from interface import GameInterface
from entities import Entity
from player import Player
from combat import CombatSystem
from world import World
from character import CharacterManager
from items import ItemManager
from quests import QuestManager

# Konfiguracja logowania
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('game.log'),
        logging.StreamHandler(sys.stdout)
    ]
)

# Utwórz logger dla głównego modułu
logger = logging.getLogger(__name__)

# Ustaw poziom logowania dla innych modułów
logging.getLogger('game').setLevel(logging.INFO)
logging.getLogger('player').setLevel(logging.INFO)
logging.getLogger('world').setLevel(logging.INFO)
logging.getLogger('combat').setLevel(logging.INFO)

class GameLauncher:
    """Klasa odpowiedzialna za uruchomienie gry w odpowiednim trybie."""
    
    def __init__(self):
        self.game_engine: Optional[GameEngine] = None
        self.gui: Optional[ModernGameGUI] = None
        self.interface: Optional[GameInterface] = None

    def initialize_game(self):
        """Inicjalizuje podstawowe komponenty gry."""
        try:
            logger.info("Inicjalizacja silnika gry...")
            self.game_engine = GameEngine()
            self.game_engine.running = True
            self.game_engine.new_game("Bohater")
            
            if game_config.get('game_settings.gui_mode', True):
                self.gui = ModernGameGUI(self.game_engine)
            else:
                self.interface = GameInterface()
                
            logger.info("Inicjalizacja zakończona pomyślnie")
            return True
        except Exception as e:
            logger.error(f"Błąd podczas inicjalizacji gry: {e}", exc_info=True)
            return False

    def start_gui_mode(self):
        """Uruchamia grę w trybie graficznym."""
        try:
            logger.info("Uruchamianie trybu GUI...")
            if not self.gui:
                self.gui = ModernGameGUI(self.game_engine)
            # Ustaw stan gry przed uruchomieniem GUI
            self.game_engine.running = True
            self.gui.start()
            
        except Exception as e:
            logger.error(f"Błąd podczas uruchamiania GUI: {e}", exc_info=True)
            self.show_error_dialog("Błąd uruchamiania", 
                                "Wystąpił błąd podczas uruchamiania interfejsu graficznego.")
    
    def start_console_mode(self):
        """Uruchamia grę w trybie konsolowym."""
        try:
            logger.info("Uruchamianie trybu konsolowego...")
            if not self.interface:
                self.interface = GameInterface()
            self.game_engine.start_game()
            
        except Exception as e:
            logger.error(f"Błąd podczas uruchamiania trybu konsolowego: {e}", exc_info=True)
            print("Wystąpił błąd podczas uruchamiania gry.")

    def show_error_dialog(self, title: str, message: str):
        """Wyświetla okno dialogowe z błędem."""
        root = tk.Tk()
        root.withdraw()
        tk.messagebox.showerror(title, message)
        root.destroy()

def parse_arguments():
    """Parsuje argumenty wiersza poleceń."""
    parser = argparse.ArgumentParser(description='Fantasy RPG Game')
    parser.add_argument(
        '--mode',
        choices=['gui', 'console'],
        default='gui',
        help='Tryb uruchomienia gry (gui lub console)'
    )
    parser.add_argument(
        '--debug',
        action='store_true',
        help='Włącza tryb debug'
    )
    parser.add_argument(
        '--config',
        help='Ścieżka do alternatywnego pliku konfiguracyjnego'
    )
    return parser.parse_args()

def main():
    """Funkcja główna uruchamiająca grę."""
    args = parse_arguments()
    
    # Ustawienie trybu debug jeśli potrzebne
    if args.debug:
        logging.getLogger().setLevel(logging.DEBUG)
        logger.debug("Tryb debug aktywny")

    # Utworzenie i inicjalizacja launchera
    launcher = GameLauncher()
    if not launcher.initialize_game():
        logger.error("Nie udało się zainicjalizować gry")
        sys.exit(1)

    try:
        if args.mode == 'gui':
            launcher.start_gui_mode()
        else:
            launcher.start_console_mode()
    except KeyboardInterrupt:
        logger.info("Gra została przerwana przez użytkownika")
    except Exception as e:
        logger.error(f"Wystąpił nieoczekiwany błąd: {e}", exc_info=True)
    finally:
        logger.info("Zamykanie gry...")

if __name__ == "__main__":
    main()Plik: ./player.py
# player.py
from inventory import Inventory
import json
import random
import time
import logging
from typing import List, Optional, Dict
from entities import Entity, Stats, StatusEffect  # Dodany import Entity
from config import game_config

# Konfiguracja loggera
logger = logging.getLogger(__name__)


class Player(Entity):
    """Klasa reprezentująca gracza."""
    
    def __init__(self, player_id: str, data: dict = None):
        if data is None:
            data = self._get_default_player_data()
        super().__init__(player_id, data)
        
        # System rozwoju postaci
        self.experience = 0
        self.experience_to_next_level = self._calculate_next_level_exp()
        self.skill_points = 0
        self.talent_points = 0
        self.health = data.get('health', 100)
        self.max_health = data.get('max_health', 100)
        self.strength = data.get('strength', 10)
        self.defense = data.get('defense', 5)
        self.agility = data.get('agility', 10)
        self.intelligence = data.get('intelligence', 10)
        
        # System umiejętności
        self.skills = {
            'combat': {
                'melee': 1,
                'ranged': 1,
                'defense': 1
            },
            'crafting': {
                'smithing': 1,
                'alchemy': 1,
                'enchanting': 1
            },
            'survival': {
                'gathering': 1,
                'tracking': 1,
                'stealth': 1
            }
        }
        self.skill_experience = {
            category: {skill: 0 for skill in skills}
            for category, skills in self.skills.items()
        }
        
        # System ekwipunku
        self.equipment_slots = {
            'head': None,
            'chest': None,
            'legs': None,
            'feet': None,
            'main_hand': None,
            'off_hand': None,
            'ring1': None,
            'ring2': None,
            'necklace': None
        }
        
        # System reputacji i relacji
        self.reputation = {}
        self.known_locations = set()
        self.discovered_npcs = set()
        
        # System questów i dziennika
        self.active_quests = []
        self.completed_quests = []
        self.quest_log = []
        self.quest_manager = None  # Referencja do QuestManagera będzie ustawiona przez initialize_quests
        
        # System osiągnięć
        self.achievements = set()
        self.achievement_progress = {}
        
        # System statystyk gracza
        self.player_stats = {
            'monsters_killed': 0,
            'quests_completed': 0,
            'items_crafted': 0,
            'distance_traveled': 0,
            'gold_earned': 0,
            'deaths': 0,
            'playtime': 0
        }
        logger.debug(f"Utworzono nową postać: {player_id}")

    def _get_default_player_data(self) -> dict:
        """Zwraca domyślne dane dla nowego gracza."""
        return {
            'name': 'Hero',
            'level': 1,
            'stats': {
                'health': 100,
                'max_health': 100,
                'stamina': 100,
                'max_stamina': 100,
                'mana': 50,
                'max_mana': 50,
                'strength': 10,
                'defense': 5,
                'agility': 10,
                'intelligence': 10
            },
            'gold': 100,
            'inventory_size': 20
        }

    def _calculate_next_level_exp(self) -> int:
        """Oblicza wymagane doświadczenie do następnego poziomu."""
        return int(100 * (self.level ** 1.5))

    def gain_experience(self, amount: int) -> List[str]:
        """Dodaje doświadczenie i sprawdza awans na wyższy poziom."""
        messages = []
        self.experience += amount
        messages.append(f"Zdobyto {amount} punktów doświadczenia!")
        
        while self.experience >= self.experience_to_next_level:
            self.level_up()
            messages.append(f"Awansowałeś na poziom {self.level}!")
            self.experience -= self.experience_to_next_level
            self.experience_to_next_level = self._calculate_next_level_exp()
            
        return messages

    def level_up(self):
        """Awansuje gracza na następny poziom."""
        self.level += 1
        self.skill_points += 3
        self.talent_points += 1
        
        # Zwiększanie podstawowych statystyk
        stat_increases = {
            'max_health': 10,
            'max_stamina': 5,
            'max_mana': 5,
            'strength': 1,
            'defense': 1,
            'agility': 1,
            'intelligence': 1
        }
        
        for stat, increase in stat_increases.items():
            current_value = getattr(self.stats, stat)
            setattr(self.stats, stat, current_value + increase)
            
        # Przywrócenie zdrowia i zasobów
        self.stats.health = self.stats.max_health
        self.stats.stamina = self.stats.max_stamina
        self.stats.mana = self.stats.max_mana
        
    # Kontynuacja klasy Player

    def gain_skill_experience(self, category: str, skill: str, amount: int) -> List[str]:
        """Dodaje doświadczenie do umiejętności."""
        messages = []
        if category not in self.skills or skill not in self.skills[category]:
            return [f"Nieznana umiejętność: {category}.{skill}"]
            
        current_level = self.skills[category][skill]
        self.skill_experience[category][skill] += amount
        
        # Sprawdź czy nastąpił awans umiejętności
        exp_needed = self._calculate_skill_level_exp(current_level)
        while self.skill_experience[category][skill] >= exp_needed:
            self.skills[category][skill] += 1
            self.skill_experience[category][skill] -= exp_needed
            new_level = self.skills[category][skill]
            
            messages.append(f"Umiejętność {skill} osiągnęła poziom {new_level}!")
            
            # Odblokowanie nowych zdolności
            if new_ability := self._check_new_abilities(category, skill, new_level):
                messages.append(f"Odblokowano nową zdolność: {new_ability}")
                
            exp_needed = self._calculate_skill_level_exp(new_level)
            
        return messages

    def _calculate_skill_level_exp(self, current_level: int) -> int:
        """Oblicza wymagane doświadczenie do następnego poziomu umiejętności."""
        return int(75 * (current_level ** 1.8))

    def _check_new_abilities(self, category: str, skill: str, level: int) -> Optional[str]:
        """Sprawdza czy na danym poziomie odblokowuje się nowa zdolność."""
        ability_unlocks = {
            'combat': {
                'melee': {
                    3: 'Potężne uderzenie',
                    5: 'Wirujący cios',
                    7: 'Rozłupanie zbroi'
                },
                'ranged': {
                    3: 'Precyzyjny strzał',
                    5: 'Strzał wielokrotny',
                    7: 'Strzał osłabiający'
                },
                'defense': {
                    3: 'Blok tarczą',
                    5: 'Kontratak',
                    7: 'Niezniszczalna postawa'
                }
            },
            'crafting': {
                'smithing': {
                    3: 'Ulepszanie broni',
                    5: 'Mistrzowska naprawa',
                    7: 'Wykuwanie magicznej broni'
                },
                'alchemy': {
                    3: 'Ulepszone mikstury',
                    5: 'Trwałe eliksiry',
                    7: 'Mistyczne wywary'
                },
                'enchanting': {
                    3: 'Podstawowe zaklęcia',
                    5: 'Potężne enchant',
                    7: 'Legendarne zaklęcia'
                }
            },
            'survival': {
                'gathering': {
                    3: 'Podwójne zbiory',
                    5: 'Rzadkie zasoby',
                    7: 'Mistrzowskie zbieractwo'
                },
                'tracking': {
                    3: 'Śledzenie zwierzyny',
                    5: 'Tropienie rzadkich stworzeń',
                    7: 'Mistrzowskie tropienie'
                },
                'stealth': {
                    3: 'Cichy chód',
                    5: 'Znikanie w cieniu',
                    7: 'Mistrzowskie skradanie'
                }
            }
        }
        
        return ability_unlocks.get(category, {}).get(skill, {}).get(level)

    def spend_skill_points(self, category: str, skill: str, points: int) -> tuple[bool, str]:
        """Wydaje punkty umiejętności na rozwój konkretnej umiejętności."""
        if points > self.skill_points:
            return False, "Nie masz wystarczającej liczby punktów umiejętności!"
            
        if category not in self.skills or skill not in self.skills[category]:
            return False, f"Nieznana umiejętność: {category}.{skill}"
            
        current_level = self.skills[category][skill]
        if current_level >= 10:  # Maksymalny poziom podstawowy
            return False, "Ta umiejętność osiągnęła maksymalny poziom!"
            
        # Wydaj punkty
        self.skill_points -= points
        self.skills[category][skill] += points
        
        # Sprawdź odblokowane zdolności
        new_level = self.skills[category][skill]
        if new_ability := self._check_new_abilities(category, skill, new_level):
            return True, f"Rozwinięto {skill} do poziomu {new_level}! Odblokowano: {new_ability}"
            
        return True, f"Rozwinięto {skill} do poziomu {new_level}!"

    def get_skill_bonus(self, category: str, skill: str) -> float:
        """Zwraca bonus z umiejętności do odpowiednich akcji."""
        if category not in self.skills or skill not in self.skills[category]:
            return 0.0
            
        skill_level = self.skills[category][skill]
        base_bonus = skill_level * 0.1  # 10% bonus na poziom
        
        # Dodatkowe bonusy z talentów i ekwipunku
        equipment_bonus = self._get_equipment_skill_bonus(category, skill)
        talent_bonus = self._get_talent_skill_bonus(category, skill)
        
        return base_bonus + equipment_bonus + talent_bonus

    def _get_equipment_skill_bonus(self, category: str, skill: str) -> float:
        """Oblicza bonus do umiejętności z ekwipunku."""
        total_bonus = 0.0
        
        for slot, item in self.equipment_slots.items():
            if not item:
                continue
            
            # Sprawdź bonusy przedmiotu do umiejętności
            item_data = item.get_data()
            if 'skill_bonuses' in item_data:
                if category in item_data['skill_bonuses']:
                    if skill in item_data['skill_bonuses'][category]:
                        total_bonus += item_data['skill_bonuses'][category][skill]
                        
        return total_bonus

    def _get_talent_skill_bonus(self, category: str, skill: str) -> float:
        """Oblicza bonus do umiejętności z talentów."""
        # Ta funkcja będzie rozbudowana gdy dodamy system talentów
        return 0.0

    def get_skill_modifiers(self) -> dict:
        """Zwraca wszystkie aktywne modyfikatory umiejętności."""
        modifiers = {}
        
        for category in self.skills:
            modifiers[category] = {}
            for skill in self.skills[category]:
                base_bonus = self.get_skill_bonus(category, skill)
                equipment_bonus = self._get_equipment_skill_bonus(category, skill)
                talent_bonus = self._get_talent_skill_bonus(category, skill)
                
                modifiers[category][skill] = {
                    'base_bonus': base_bonus,
                    'equipment_bonus': equipment_bonus,
                    'talent_bonus': talent_bonus,
                    'total': base_bonus + equipment_bonus + talent_bonus
                }
                
        return modifiers
    
    # Kontynuacja klasy Player

    def equip_item(self, item_id: str) -> tuple[bool, str]:
        """Zakłada przedmiot na odpowiedni slot."""
        item = self.inventory.item_manager.get_item(item_id)
        if not item:
            return False, "Nie znaleziono przedmiotu!"
            
        # Sprawdź czy gracz ma przedmiot w ekwipunku
        if not self.inventory.has_item(item_id):
            return False, "Nie masz tego przedmiotu w ekwipunku!"
            
        # Sprawdź wymagania przedmiotu
        if not self._check_item_requirements(item):
            return False, "Nie spełniasz wymagań tego przedmiotu!"
            
        # Określ odpowiedni slot
        slot = self._determine_equipment_slot(item)
        if not slot:
            return False, "Nie możesz założyć tego przedmiotu!"
            
        # Zdejmij obecnie założony przedmiot jeśli istnieje
        if self.equipment_slots[slot]:
            self.unequip_item(slot)
            
        # Załóż nowy przedmiot
        self.equipment_slots[slot] = item_id
        self.inventory.remove_item(item_id, 1)
        
        # Aplikuj bonusy z przedmiotu
        self._apply_item_bonuses(item, True)
        
        return True, f"Założono {item.name} na slot {slot}!"

    def unequip_item(self, slot: str) -> tuple[bool, str]:
        """Zdejmuje przedmiot z podanego slotu."""
        if slot not in self.equipment_slots:
            return False, "Nieprawidłowy slot!"
            
        item_id = self.equipment_slots[slot]
        if not item_id:
            return False, "Ten slot jest pusty!"
            
        # Sprawdź czy jest miejsce w ekwipunku
        if not self.inventory.can_add_item(item_id):
            return False, "Brak miejsca w ekwipunku!"
            
        # Zdejmij bonusy przedmiotu
        item = self.inventory.item_manager.get_item(item_id)
        self._apply_item_bonuses(item, False)
        
        # Przenieś przedmiot do ekwipunku
        self.equipment_slots[slot] = None
        self.inventory.add_item(item_id, 1)
        
        return True, f"Zdjęto {item.name} ze slotu {slot}!"

    def _check_item_requirements(self, item) -> bool:
        """Sprawdza czy gracz spełnia wymagania przedmiotu."""
        if 'requirements' not in item.properties:
            return True
            
        reqs = item.properties['requirements']
        
        # Sprawdź wymagany poziom
        if 'level' in reqs and self.level < reqs['level']:
            return False
            
        # Sprawdź wymagane umiejętności
        if 'skills' in reqs:
            for category, skill_reqs in reqs['skills'].items():
                for skill, required_level in skill_reqs.items():
                    if self.skills[category][skill] < required_level:
                        return False
                        
        # Sprawdź wymagane statystyki
        if 'stats' in reqs:
            for stat, required_value in reqs['stats'].items():
                if getattr(self.stats, stat) < required_value:
                    return False
                    
        return True
    
    def use_item(self, item_id: str) -> tuple[bool, str]:
        item = self.inventory.get_item(item_id)
        if item:
            if item.type == 'consumable':
                if item.effect == 'restore_health':
                    self.health = min(self.health + item.value, self.max_health)
                    return True, f"Used {item.name} and restored {item.value} health."
                elif item.effect == 'restore_mana':
                    self.mana = min(self.mana + item.value, self.max_mana)
                    return True, f"Used {item.name} and restored {item.value} mana."
            # Add more item type handling here
        return False, "Failed to use the item."

    def _determine_equipment_slot(self, item) -> Optional[str]:
        """Określa odpowiedni slot dla przedmiotu."""
        type_to_slot = {
            'weapon': 'main_hand',
            'shield': 'off_hand',
            'helmet': 'head',
            'armor': 'chest',
            'legs': 'legs',
            'boots': 'feet',
            'ring': 'ring1',  # lub ring2
            'necklace': 'necklace'
        }
        
        item_type = item.properties.get('equipment_type')
        if not item_type:
            return None
            
        # Specjalna obsługa pierścieni
        if item_type == 'ring':
            if not self.equipment_slots['ring1']:
                return 'ring1'
            elif not self.equipment_slots['ring2']:
                return 'ring2'
            else:
                return 'ring1'  # Domyślnie zastąp pierwszy pierścień
                
        return type_to_slot.get(item_type)

    def _apply_item_bonuses(self, item, adding: bool = True):
        """Aplikuje lub usuwa bonusy z przedmiotu."""
        if 'bonuses' not in item.properties:
            return
            
        multiplier = 1 if adding else -1
        bonuses = item.properties['bonuses']
        
        # Aplikuj bonusy do statystyk
        for stat, value in bonuses.get('stats', {}).items():
            current = getattr(self.stats, stat)
            setattr(self.stats, stat, current + (value * multiplier))
            
        # Aplikuj bonusy do umiejętności
        for category, skills in bonuses.get('skills', {}).items():
            for skill, value in skills.items():
                self.skill_bonuses[category][skill] = self.skill_bonuses.get(category, {}).get(skill, 0) + (value * multiplier)

    def interact_with_object(self, object_id: str, world) -> tuple[bool, str]:
        """Interakcja z obiektami w świecie gry."""
        obj = world.get_object(object_id)
        if not obj:
            return False, "Nie znaleziono obiektu!"
            
        # Sprawdź czy obiekt jest w zasięgu
        if not world.is_object_in_range(self.position, obj.position):
            return False, "Ten obiekt jest zbyt daleko!"
            
        # Sprawdź wymagane umiejętności
        if required_skill := obj.get_required_skill():
            category, skill, level = required_skill
            if self.skills[category][skill] < level:
                return False, f"Wymagana umiejętność: {skill} poziom {level}!"
                
        # Wykonaj interakcję
        return obj.interact(self)

    def use_ability(self, ability_id: str, target=None) -> tuple[bool, str]:
        """Używa zdolności."""
        # Sprawdź czy zdolność jest dostępna
        if not self.has_ability(ability_id):
            return False, "Nie znasz tej zdolności!"
            
        ability = self.get_ability(ability_id)
        
        # Sprawdź koszty i cooldowny
        if self.stats.stamina < ability['stamina_cost']:
            return False, "Niewystarczająca stamina!"
        if self.stats.mana < ability['mana_cost']:
            return False, "Niewystarczająca mana!"
            
        if ability_id in self.ability_cooldowns:
            return False, f"Zdolność odnowi się za {self.ability_cooldowns[ability_id]} sekund!"
            
        # Użyj zdolności
        success, message = super().use_ability(ability_id, target)
        if success:
            self.stats.stamina -= ability['stamina_cost']
            self.stats.mana -= ability['mana_cost']
            self.ability_cooldowns[ability_id] = ability['cooldown']
            
            # Dodaj doświadczenie do odpowiedniej umiejętności
            if 'skill_experience' in ability:
                category, skill = ability['skill_experience']
                self.gain_skill_experience(category, skill, 10)
                
        return success, message

    def rest(self, duration: int) -> tuple[bool, str]:
        """Odpoczynek odnawiający zasoby."""
        if self.in_combat:
            return False, "Nie możesz odpoczywać podczas walki!"
            
        # Oblicz ilość odnowionych zasobów
        health_regen = min(
            self.stats.max_health - self.stats.health,
            duration * (self.stats.max_health * 0.1)
        )
        stamina_regen = min(
            self.stats.max_stamina - self.stats.stamina,
            duration * (self.stats.max_stamina * 0.2)
        )
        mana_regen = min(
            self.stats.max_mana - self.stats.mana,
            duration * (self.stats.max_mana * 0.15)
        )
        
        # Aplikuj regenerację
        self.stats.health += health_regen
        self.stats.stamina += stamina_regen
        self.stats.mana += mana_regen
        
        return True, f"Odpocząłeś przez {duration} sekund i odnowiłeś zasoby!"

    def get_state(self) -> dict:
        """Rozszerzona wersja get_state z dodatkowymi informacjami o graczu."""
        base_state = super().get_state()
        player_state = {
            'experience': self.experience,
            'experience_to_next_level': self.experience_to_next_level,
            'skill_points': self.skill_points,
            'equipment': self.equipment_slots,
            'reputation': self.reputation,
            'active_quests': [quest.id for quest in self.active_quests],
            'achievements': list(self.achievements),
            'known_locations': list(self.known_locations),
            'player_stats': self.player_stats
        }
        return {**base_state, **player_state}
    
    # Kontynuacja klasy Player

    def accept_quest(self, quest_id: str) -> tuple[bool, str]:
        """Przyjmuje nowy quest."""
        if quest_id in [quest.id for quest in self.active_quests]:
            return False, "Ten quest jest już aktywny!"
            
        if quest_id in [quest.id for quest in self.completed_quests]:
            quest = self.quest_manager.get_quest(quest_id)
            if not quest.repeatable:
                return False, "Ten quest został już ukończony!"
        
        quest = self.quest_manager.get_quest(quest_id)
        if not quest:
            return False, "Nie znaleziono questa!"
            
        # Sprawdź wymagania questa
        if not self._check_quest_requirements(quest):
            return False, f"Nie spełniasz wymagań questa! (Wymagany poziom: {quest.min_level})"
            
        # Dodaj quest do aktywnych
        self.active_quests.append(quest)
        quest.start()
        
        # Dodaj wpis do dziennika
        self.quest_log.append({
            'timestamp': time.time(),
            'type': 'quest_accepted',
            'quest_id': quest_id,
            'quest_name': quest.name
        })
        
        return True, f"Przyjęto quest: {quest.name}"

    def _check_quest_requirements(self, quest) -> bool:
        """Sprawdza czy gracz spełnia wymagania questa."""
        if self.level < quest.min_level:
            return False
            
        # Sprawdź wymagania reputacji
        if hasattr(quest, 'reputation_requirements'):
            for faction, required_rep in quest.reputation_requirements.items():
                if self.reputation.get(faction, 0) < required_rep:
                    return False
                    
        # Sprawdź wymagane umiejętności
        if hasattr(quest, 'skill_requirements'):
            for category, skill_reqs in quest.skill_requirements.items():
                for skill, required_level in skill_reqs.items():
                    if self.skills[category][skill] < required_level:
                        return False
                        
        return True

    def update_quest_progress(self, event_type: str, target_id: str, amount: int = 1) -> List[str]:
        """Aktualizuje postęp questów na podstawie wydarzeń w grze."""
        messages = []
        for quest in self.active_quests:
            if quest.check_objective(event_type, target_id):
                progress = quest.update_progress(amount)
                messages.extend(progress)
                
                # Sprawdź czy quest został ukończony
                if quest.is_completed():
                    reward_messages = self.complete_quest(quest.id)
                    messages.extend(reward_messages)
                    
        return messages

    def complete_quest(self, quest_id: str) -> List[str]:
        """Kończy quest i przyznaje nagrody."""
        messages = []
        quest = next((q for q in self.active_quests if q.id == quest_id), None)
        if not quest:
            return ["Quest nie jest aktywny!"]
            
        # Usuń z aktywnych i dodaj do ukończonych
        self.active_quests.remove(quest)
        if not quest.repeatable:
            self.completed_quests.append(quest)
            
        # Przyznaj nagrody
        rewards = quest.get_rewards()
        messages.append(f"Ukończono quest: {quest.name}!")
        
        for reward_type, value in rewards.items():
            if reward_type == 'experience':
                messages.extend(self.gain_experience(value))
            elif reward_type == 'gold':
                self.gold += value
                messages.append(f"Otrzymano {value} złota!")
            elif reward_type == 'items':
                for item_id, amount in value.items():
                    success, msg = self.inventory.add_item(item_id, amount)
                    messages.append(msg)
            elif reward_type == 'reputation':
                for faction, amount in value.items():
                    self.add_reputation(faction, amount)
                    messages.append(f"Zmiana reputacji z {faction}: {amount}")
            elif reward_type == 'skill_experience':
                for category, skill_rewards in value.items():
                    for skill, amount in skill_rewards.items():
                        messages.extend(self.gain_skill_experience(category, skill, amount))
                        
        # Aktualizuj statystyki
        self.player_stats['quests_completed'] += 1
        
        # Sprawdź osiągnięcia związane z questami
        self._check_quest_achievements()
        
        return messages

    def _check_quest_achievements(self):
        """Sprawdza i przyznaje osiągnięcia związane z questami."""
        quest_achievements = {
            'quest_novice': {
                'name': 'Początkujący poszukiwacz przygód',
                'requirement': 5,
                'type': 'quests_completed'
            },
            'quest_expert': {
                'name': 'Ekspert zadań',
                'requirement': 25,
                'type': 'quests_completed'
            },
            'quest_master': {
                'name': 'Mistrz zadań',
                'requirement': 100,
                'type': 'quests_completed'
            }
        }
        
        for achievement_id, data in quest_achievements.items():
            if (achievement_id not in self.achievements and 
                self.player_stats[data['type']] >= data['requirement']):
                self.unlock_achievement(achievement_id)

    def unlock_achievement(self, achievement_id: str) -> tuple[bool, str]:
        """Odblokowuje osiągnięcie."""
        if achievement_id in self.achievements:
            return False, "To osiągnięcie zostało już odblokowane!"
            
        achievement_data = game_config.get(f'achievements.{achievement_id}')
        if not achievement_data:
            return False, "Nieznane osiągnięcie!"
            
        self.achievements.add(achievement_id)
        
        # Przyznaj nagrody za osiągnięcie
        if 'rewards' in achievement_data:
            self._grant_achievement_rewards(achievement_data['rewards'])
            
        return True, f"Odblokowano osiągnięcie: {achievement_data['name']}!"

    def _grant_achievement_rewards(self, rewards: dict):
        """Przyznaje nagrody za osiągnięcie."""
        for reward_type, value in rewards.items():
            if reward_type == 'experience':
                self.gain_experience(value)
            elif reward_type == 'gold':
                self.gold += value
            elif reward_type == 'items':
                for item_id, amount in value.items():
                    self.inventory.add_item(item_id, amount)

    def save_game(self) -> dict:
        """Przygotowuje dane do zapisu stanu gry."""
        return {
            'player_data': {
                'basic_info': {
                    'name': self.name,
                    'level': self.level,
                    'experience': self.experience,
                    'gold': self.gold
                },
                'stats': self.stats.__dict__,
                'skills': self.skills,
                'skill_experience': self.skill_experience,
                'equipment': self.equipment_slots,
                'inventory': self.inventory.get_save_data(),
                'reputation': self.reputation,
                'quests': {
                    'active': [quest.id for quest in self.active_quests],
                    'completed': [quest.id for quest in self.completed_quests]
                },
                'achievements': list(self.achievements),
                'player_stats': self.player_stats,
                'known_locations': list(self.known_locations),
                'quest_log': self.quest_log
            },
            'game_state': {
                'current_location': self.current_location,
                'game_time': game_config.get('game_time'),
                'difficulty': game_config.get('game_settings.difficulty')
            }
        }

    def load_game(self, save_data: dict):
        """Ładuje stan gry z zapisanych danych."""
        try:
            player_data = save_data['player_data']
            
            # Podstawowe informacje
            self.name = player_data['basic_info']['name']
            self.level = player_data['basic_info']['level']
            self.experience = player_data['basic_info']['experience']
            self.gold = player_data['basic_info']['gold']
            
            # Statystyki
            for stat, value in player_data['stats'].items():
                setattr(self.stats, stat, value)
                
            # Umiejętności i doświadczenie
            self.skills = player_data['skills']
            self.skill_experience = player_data['skill_experience']
            
            # Ekwipunek i wyposażenie
            self.equipment_slots = player_data['equipment']
            self.inventory.load_save_data(player_data['inventory'])
            
            # Reputacja i osiągnięcia
            self.reputation = player_data['reputation']
            self.achievements = set(player_data['achievements'])
            
            # Questy
            self._load_quests(player_data['quests'])
            
            # Pozostałe dane
            self.player_stats = player_data['player_stats']
            self.known_locations = set(player_data['known_locations'])
            self.quest_log = player_data['quest_log']
            
            # Stan gry
            game_state = save_data['game_state']
            self.current_location = game_state['current_location']
            
            return True, "Pomyślnie wczytano stan gry!"
            
        except Exception as e:
            logger.error(f"Błąd podczas wczytywania stanu gry: {e}")
            return False, "Wystąpił błąd podczas wczytywania stanu gry!"

    def _load_quests(self, quest_data: dict):
        """Ładuje stan questów."""
        self.active_quests = []
        self.completed_quests = []
        
        for quest_id in quest_data['active']:
            quest = self.quest_manager.get_quest(quest_id)
            if quest:
                self.active_quests.append(quest)
                
        for quest_id in quest_data['completed']:
            quest = self.quest_manager.get_quest(quest_id)
            if quest:
                self.completed_quests.append(quest)
                
    def get_loot(self) -> List[dict]:
        """Zwraca łup z gracza (w przypadku śmierci)."""
        loot = []
    
        # Dodaj część złota do łupu
        if self.gold > 0:
            gold_drop = int(self.gold * 0.1)  # 10% złota
            if gold_drop > 0:
                loot.append({
                    'id': 'gold',
                    'amount': gold_drop
                })
    
        # Dodaj losowe przedmioty z ekwipunku
        if self.inventory and self.inventory.items:
            for item_id, quantity in self.inventory.items.items():
                # 10% szansa na upuszczenie każdego przedmiotu
                if random.random() < 0.1:
                    drop_quantity = min(quantity, random.randint(1, quantity))
                    loot.append({
                        'id': item_id,
                        'amount': drop_quantity
                    })
    
        return loot
    
    def initialize_quests(self, quest_manager):
        """Inicjalizuje system questów dla gracza."""
        self.quest_manager = quest_manager
        # Możesz tutaj dodać inicjalizację domyślnych questów, jeśli jest taka potrzeba
        logger.info(f"Zainicjalizowano system questów dla gracza {self.name}")

    def accept_quest(self, quest_id: str) -> tuple[bool, str]:
        """Przyjmuje nowy quest."""
        if not self.quest_manager:
            return False, "System questów nie został zainicjalizowany!"
            
        if quest_id in [quest.id for quest in self.active_quests]:
            return False, "Ten quest jest już aktywny!"
            
        quest = self.quest_manager.get_quest(quest_id)
        if not quest:
            return False, "Nie znaleziono questa!"
            
        self.active_quests.append(quest)
        self.quest_log.append({
            'timestamp': time.time(),
            'type': 'quest_accepted',
            'quest_id': quest_id,
            'quest_name': quest.name
        })
        
        return True, f"Przyjęto quest: {quest.name}"

    def complete_quest(self, quest_id: str) -> tuple[bool, str]:
        """Kończy quest."""
        quest = next((q for q in self.active_quests if q.id == quest_id), None)
        if not quest:
            return False, "Ten quest nie jest aktywny!"
            
        self.active_quests.remove(quest)
        self.completed_quests.append(quest)
        self.quest_log.append({
            'timestamp': time.time(),
            'type': 'quest_completed',
            'quest_id': quest_id,
            'quest_name': quest.name
        })
        
        return True, f"Ukończono quest: {quest.name}!"

    def get_available_quests(self) -> List[str]:
        """Zwraca listę dostępnych questów."""
        if not self.quest_manager:
            return []
            
        return self.quest_manager.get_available_quests(self)

    def update_quest_progress(self, event_type: str, target_id: str, amount: int = 1):
        """Aktualizuje postęp questów."""
        if not self.quest_manager:
            return
            
        for quest in self.active_quests:
            if quest.check_objective(event_type, target_id):
                quest.update_progress(amount)
                if quest.is_completed():
                    self.complete_quest(quest.id)
    
                
    Plik: ./quests.py
# quests.py
import json
from typing import Dict, List, Optional

class Quest:
    def __init__(self, quest_id: str, data: dict):
        self.id = quest_id
        self.name = data['name']
        self.description = data['description']
        self.giver = data['giver']
        self.type = data['type']
        self.difficulty = data['difficulty']
        self.min_level = data.get('min_level', 1)
        self.stages = data['stages']
        self.rewards = data['rewards']
        self.current_stage = 0
        self.completed = False
        self.active = False
        self.failed = False
        self.time_limit = data.get('time_limit', None)
        self.repeatable = data.get('repeatable', False)
        self.cooldown = data.get('cooldown', None)
        self.prerequisites = data.get('prerequisites', {})
        self.choices = []
        self.failure_penalties = data.get('failure_penalties', {})

    def start(self):
        """Rozpoczyna quest."""
        self.active = True
        self.current_stage = 0
        return f"Rozpoczęto zadanie: {self.name}"

    def advance_stage(self):
        """Przechodzi do następnego etapu questa."""
        if self.current_stage < len(self.stages) - 1:
            self.current_stage += 1
            return True, f"Ukończono etap questa: {self.stages[self.current_stage-1]['description']}"
        else:
            self.complete()
            return False, "Quest ukończony!"

    def complete(self):
        """Kończy quest jako ukończony."""
        self.completed = True
        self.active = False
        return "Quest ukończony! Odbierz nagrody."

    def fail(self):
        """Oznacza quest jako nieudany."""
        self.failed = True
        self.active = False
        return "Quest nieudany!"

    def can_start(self, player) -> tuple[bool, str]:
        """Sprawdza czy gracz może rozpocząć questa."""
        if player.level < self.min_level:
            return False, f"Wymagany poziom: {self.min_level}"
        
        if self.prerequisites:
            if 'reputation' in self.prerequisites:
                for faction, required_rep in self.prerequisites['reputation'].items():
                    if player.get_reputation(faction) < required_rep:
                        return False, f"Wymagana reputacja z {faction}: {required_rep}"
        
        return True, "Możesz rozpocząć questa!"

    def get_current_stage(self) -> dict:
        """Zwraca informacje o aktualnym etapie questa."""
        if 0 <= self.current_stage < len(self.stages):
            return self.stages[self.current_stage]
        return {}

    def get_stage_objective(self) -> str:
        """Zwraca opis aktualnego celu questa."""
        stage = self.get_current_stage()
        if stage:
            return stage['description']
        return ""

class QuestManager:
    def __init__(self, data_file='data/quests.json'):
        self.quests: Dict[str, Quest] = {}
        self.active_quests: List[Quest] = []
        self.completed_quests: List[Quest] = []
        self.load_quests(data_file)

    def load_quests(self, data_file: str):
        """Ładuje questy z pliku JSON."""
        try:
            with open(data_file, 'r', encoding='utf-8') as f:
                data = json.load(f)
                for quest_id, quest_data in data['quests'].items():
                    self.quests[quest_id] = Quest(quest_id, quest_data)
        except FileNotFoundError:
            print(f"Błąd: Nie znaleziono pliku {data_file}")
        except json.JSONDecodeError:
            print(f"Błąd: Nieprawidłowy format pliku {data_file}")

    def get_available_quests(self, player, location: str) -> List[Quest]:
        """Zwraca listę questów dostępnych w danej lokacji dla gracza."""
        available_quests = []
        for quest in self.quests.values():
            if not quest.active and not quest.completed and quest.giver in location:
                can_start, _ = quest.can_start(player)
                if can_start:
                    available_quests.append(quest)
        return available_quests

    def start_quest(self, quest_id: str, player) -> tuple[bool, str]:
        """Rozpoczyna quest dla gracza."""
        if quest_id not in self.quests:
            return False, "Nie znaleziono questa!"
        
        quest = self.quests[quest_id]
        
        if quest.active:
            return False, "Ten quest jest już aktywny!"
            
        if quest.completed and not quest.repeatable:
            return False, "Ten quest został już ukończony!"
            
        can_start, message = quest.can_start(player)
        if not can_start:
            return False, message
            
        quest.start()
        self.active_quests.append(quest)
        return True, f"Rozpoczęto quest: {quest.name}"

    def update_quest_progress(self, player, event_type: str, target: str, count: int = 1) -> List[str]:
        """Aktualizuje postęp questów na podstawie wydarzeń w grze."""
        messages = []
        for quest in self.active_quests:
            stage = quest.get_current_stage()
            if stage['objective'] == event_type and stage['target'] == target:
                # Sprawdź czy jest wymagana liczba
                if 'count' in stage:
                    if count >= stage['count']:
                        success, message = quest.advance_stage()
                        messages.append(message)
                        if not success:  # Quest ukończony
                            self.complete_quest(quest.id, player)
                else:
                    success, message = quest.advance_stage()
                    messages.append(message)
                    if not success:  # Quest ukończony
                        self.complete_quest(quest.id, player)
        return messages

    def complete_quest(self, quest_id: str, player) -> tuple[bool, str]:
        """Kończy questa i przyznaje nagrody."""
        if quest_id not in self.quests:
            return False, "Nie znaleziono questa!"
            
        quest = self.quests[quest_id]
        if not quest.active:
            return False, "Ten quest nie jest aktywny!"
            
        # Przyznaj nagrody
        rewards = quest.rewards
        if 'gold' in rewards:
            player.gold += rewards['gold']
        if 'exp' in rewards:
            player.gain_exp(rewards['exp'])
        if 'items' in rewards:
            for item_id in rewards['items']:
                player.inventory.add_item(item_id)
        if 'reputation' in rewards:
            for faction, value in rewards['reputation'].items():
                player.add_reputation(faction, value)
                
        quest.complete()
        self.active_quests.remove(quest)
        self.completed_quests.append(quest)
        return True, f"Ukończono quest: {quest.name}! Otrzymano nagrody."

    def get_quest_status(self, quest_id: str) -> Optional[str]:
        """Zwraca status questa."""
        if quest_id not in self.quests:
            return None
            
        quest = self.quests[quest_id]
        if quest.completed:
            return "Ukończony"
        elif quest.failed:
            return "Nieudany"
        elif quest.active:
            return f"W trakcie ({quest.get_stage_objective()})"
        else:
            return "Dostępny"

    def show_available_quests(self, player):
        """Wyświetla dostępne questy."""
        print("\n=== Dostępne Questy ===")
        available_quests = self.get_available_quests(player, player.current_location)
        if not available_quests:
            print("Brak dostępnych questów w tej lokacji.")
            return
            
        for quest in available_quests:
            print(f"\n- {quest.name} (Poziom: {quest.min_level})")
            print(f"  Trudność: {quest.difficulty}")
            print(f"  Opis: {quest.description}")

    def show_active_quests(self):
        """Wyświetla aktywne questy."""
        print("\n=== Aktywne Questy ===")
        if not self.active_quests:
            print("Nie masz aktywnych questów.")
            return
            
        for quest in self.active_quests:
            print(f"\n- {quest.name}")
            print(f"  Aktualny cel: {quest.get_stage_objective()}")
            if quest.time_limit:
                print(f"  Pozostały czas: {quest.time_limit}")

    def show_completed_quests(self):
        """Wyświetla ukończone questy."""
        print("\n=== Ukończone Questy ===")
        if not self.completed_quests:
            print("Nie masz ukończonych questów.")
            return
            
        for quest in self.completed_quests:
            print(f"- {quest.name}")Plik: ./save_load.py
# save_load.py

import json
import os
import time
import zlib
import base64
import logging
from typing import Dict, Optional, Tuple
from pathlib import Path
from dataclasses import dataclass
import hashlib

from exceptions import (
    SaveLoadError, SaveFileCorruptedError, 
    SaveVersionMismatchError, GameStateError
)
from config import game_config

logger = logging.getLogger(__name__)

@dataclass
class SaveMetadata:
    """Metadane zapisu gry."""
    version: str
    timestamp: float
    player_name: str
    player_level: int
    location: str
    playtime: float
    save_name: str
    checksum: str

class SaveManager:
    """Zarządza zapisem i odczytem stanu gry."""
    
    def __init__(self, save_dir: str = 'saves'):
        self.save_dir = Path(save_dir)
        self.save_dir.mkdir(exist_ok=True)
        self.current_save: Optional[str] = None
        self.auto_backup = game_config.get('game_settings.auto_backup', True)
        self.compression_level = game_config.get('game_settings.save_compression_level', 6)
        self.max_autosaves = game_config.get('game_settings.max_autosaves', 3)
        
    def save_game(self, game_state: dict, save_name: str = None) -> Tuple[bool, str]:
        """Zapisuje stan gry do pliku."""
        try:
            # Jeśli nazwa nie została podana, użyj timestampa
            if not save_name:
                save_name = f"autosave_{int(time.time())}"
            
            save_path = self.save_dir / f"{save_name}.sav"
            
            # Przygotuj dane do zapisu
            save_data = self._prepare_save_data(game_state)
            
            # Zapisz plik
            self._write_save_file(save_path, save_data)
            
            # Aktualizuj metadane
            self._update_save_metadata(save_name, save_data)
            
            # Zarządzaj automatycznymi zapisami
            if save_name.startswith('autosave'):
                self._manage_autosaves()
            
            # Utwórz kopię zapasową jeśli potrzeba
            if self.auto_backup and not save_name.startswith('autosave'):
                self._create_backup(save_data)
                
            logger.info(f"Gra została zapisana do: {save_path}")
            return True, "Gra została pomyślnie zapisana!"
            
        except Exception as e:
            logger.error(f"Błąd podczas zapisywania gry: {e}")
            return False, f"Nie udało się zapisać gry: {str(e)}"

    def load_game(self, save_name: str) -> Tuple[bool, str, Optional[dict]]:
        """Wczytuje stan gry z pliku."""
        try:
            save_path = self.save_dir / f"{save_name}.sav"
            if not save_path.exists():
                return False, "Nie znaleziono pliku zapisu!", None
                
            # Wczytaj i zdekoduj dane
            save_data = self._read_save_file(save_path)
            
            # Sprawdź integralność danych
            if not self._verify_save_integrity(save_data):
                raise SaveFileCorruptedError("Plik zapisu jest uszkodzony!")
                
            # Sprawdź kompatybilność wersji
            if not self._check_version_compatibility(save_data['metadata']['version']):
                raise SaveVersionMismatchError("Niekompatybilna wersja zapisu!")
                
            # Ustaw aktualny zapis
            self.current_save = save_name
            
            logger.info(f"Wczytano grę z: {save_path}")
            return True, "Gra została pomyślnie wczytana!", save_data['game_state']
            
        except SaveLoadError as e:
            logger.error(f"Błąd podczas wczytywania gry: {e}")
            return False, str(e), None
        except Exception as e:
            logger.error(f"Nieoczekiwany błąd podczas wczytywania gry: {e}")
            return False, f"Nie udało się wczytać gry: {str(e)}", None

    def _prepare_save_data(self, game_state: dict) -> dict:
        """Przygotowuje dane do zapisu."""
        # Utwórz metadane
        metadata = {
            'version': game_config.get('version'),
            'timestamp': time.time(),
            'player_name': game_state['player']['name'],
            'player_level': game_state['player']['level'],
            'location': game_state['player']['current_location'],
            'playtime': game_state['game_time'],
            'save_name': game_state.get('save_name', 'Unnamed Save'),
        }
        
        # Skompresuj stan gry
        compressed_state = self._compress_data(game_state)
        
        # Oblicz checksum
        checksum = self._calculate_checksum(compressed_state)
        metadata['checksum'] = checksum
        
        return {
            'metadata': metadata,
            'game_state': compressed_state
        }

    def _write_save_file(self, save_path: Path, save_data: dict):
        """Zapisuje dane do pliku."""
        try:
            with save_path.open('w', encoding='utf-8') as f:
                json.dump(save_data, f, indent=4)
        except Exception as e:
            raise SaveLoadError(f"Nie można zapisać pliku: {e}")

    def _read_save_file(self, save_path: Path) -> dict:
        """Wczytuje dane z pliku."""
        try:
            with save_path.open('r', encoding='utf-8') as f:
                save_data = json.load(f)
                
            # Zdekompresuj stan gry
            save_data['game_state'] = self._decompress_data(save_data['game_state'])
            return save_data
            
        except json.JSONDecodeError:
            raise SaveFileCorruptedError("Plik zapisu jest uszkodzony!")
        except Exception as e:
            raise SaveLoadError(f"Nie można wczytać pliku: {e}")

    def _compress_data(self, data: dict) -> str:
        """Kompresuje dane gry."""
        try:
            json_str = json.dumps(data)
            compressed = zlib.compress(json_str.encode(), self.compression_level)
            return base64.b64encode(compressed).decode()
        except Exception as e:
            raise SaveLoadError(f"Błąd kompresji danych: {e}")

    def _decompress_data(self, compressed_data: str) -> dict:
        """Dekompresuje dane gry."""
        try:
            compressed = base64.b64decode(compressed_data)
            json_str = zlib.decompress(compressed).decode()
            return json.loads(json_str)
        except Exception as e:
            raise SaveLoadError(f"Błąd dekompresji danych: {e}")

    def _calculate_checksum(self, data: str) -> str:
        """Oblicza sumę kontrolną danych."""
        return hashlib.sha256(data.encode()).hexdigest()

    def _verify_save_integrity(self, save_data: dict) -> bool:
        """Sprawdza integralność pliku zapisu."""
        stored_checksum = save_data['metadata']['checksum']
        calculated_checksum = self._calculate_checksum(save_data['game_state'])
        return stored_checksum == calculated_checksum

    def _check_version_compatibility(self, save_version: str) -> bool:
        """Sprawdza kompatybilność wersji zapisu."""
        current_version = game_config.get('version')
        save_major_version = int(save_version.split('.')[0])
        current_major_version = int(current_version.split('.')[0])
        return save_major_version == current_major_version

    def _create_backup(self, save_data: dict):
        """Tworzy kopię zapasową zapisu."""
        try:
            backup_dir = self.save_dir / 'backups'
            backup_dir.mkdir(exist_ok=True)
            
            timestamp = int(time.time())
            backup_path = backup_dir / f"backup_{timestamp}.sav"
            
            self._write_save_file(backup_path, save_data)
            logger.info(f"Utworzono kopię zapasową: {backup_path}")
            
            # Usuń stare kopie zapasowe
            self._cleanup_old_backups()
            
        except Exception as e:
            logger.error(f"Nie udało się utworzyć kopii zapasowej: {e}")

    def _manage_autosaves(self):
        """Zarządza automatycznymi zapisami."""
        autosaves = sorted([
            f for f in self.save_dir.glob("autosave_*.sav")
        ], key=lambda f: f.stat().st_mtime, reverse=True)
        
        # Usuń najstarsze autosave'y jeśli przekroczono limit
        while len(autosaves) > self.max_autosaves:
            autosave_to_remove = autosaves.pop()
            try:
                autosave_to_remove.unlink()
                logger.info(f"Usunięto stary autosave: {autosave_to_remove}")
            except Exception as e:
                logger.error(f"Nie udało się usunąć autosave'a: {e}")

    def _cleanup_old_backups(self):
        """Usuwa stare kopie zapasowe."""
        backup_dir = self.save_dir / 'backups'
        if not backup_dir.exists():
            return
            
        max_backups = game_config.get('game_settings.max_backups', 5)
        backups = sorted([
            f for f in backup_dir.glob("backup_*.sav")
        ], key=lambda f: f.stat().st_mtime, reverse=True)
        
        # Usuń najstarsze kopie zapasowe
        for backup in backups[max_backups:]:
            try:
                backup.unlink()
                logger.info(f"Usunięto starą kopię zapasową: {backup}")
            except Exception as e:
                logger.error(f"Nie udało się usunąć kopii zapasowej: {e}")

    def get_save_list(self) -> List[SaveMetadata]:
        """Zwraca listę dostępnych zapisów."""
        saves = []
        for save_path in self.save_dir.glob("*.sav"):
            try:
                with save_path.open('r', encoding='utf-8') as f:
                    save_data = json.load(f)
                    metadata = SaveMetadata(**save_data['metadata'])
                    saves.append(metadata)
            except Exception as e:
                logger.error(f"Błąd podczas czytania metadanych zapisu {save_path}: {e}")
                
        return sorted(saves, key=lambda x: x.timestamp, reverse=True)

    def delete_save(self, save_name: str) -> Tuple[bool, str]:
        """Usuwa plik zapisu."""
        try:
            save_path = self.save_dir / f"{save_name}.sav"
            if not save_path.exists():
                return False, "Nie znaleziono pliku zapisu!"
                
            save_path.unlink()
            logger.info(f"Usunięto zapis: {save_path}")
            return True, "Zapis został pomyślnie usunięty!"
            
        except Exception as e:
            logger.error(f"Błąd podczas usuwania zapisu: {e}")
            return False, f"Nie udało się usunąć zapisu: {str(e)}"

    def rename_save(self, old_name: str, new_name: str) -> Tuple[bool, str]:
        """Zmienia nazwę pliku zapisu."""
        try:
            old_path = self.save_dir / f"{old_name}.sav"
            new_path = self.save_dir / f"{new_name}.sav"
            
            if not old_path.exists():
                return False, "Nie znaleziono pliku zapisu!"
                
            if new_path.exists():
                return False, "Plik o podanej nazwie już istnieje!"
                
            old_path.rename(new_path)
            
            # Aktualizuj metadane
            with new_path.open('r', encoding='utf-8') as f:
                save_data = json.load(f)
                save_data['metadata']['save_name'] = new_name
                
            with new_path.open('w', encoding='utf-8') as f:
                json.dump(save_data, f, indent=4)
                
            logger.info(f"Zmieniono nazwę zapisu z {old_name} na {new_name}")
            return True, "Nazwa zapisu została pomyślnie zmieniona!"
            
        except Exception as e:
            logger.error(f"Błąd podczas zmiany nazwy zapisu: {e}")
            return False, f"Nie udało się zmienić nazwy zapisu: {str(e)}"Plik: ./skills.py
Plik: ./utils.py
Plik: ./world.py
# world.py
from typing import Dict, List, Optional, Set
import json
import random
from dataclasses import dataclass
from config import game_config
import logging

logger = logging.getLogger(__name__)

@dataclass
class Weather:
    """Klasa reprezentująca pogodę w lokacji."""
    type: str  # sunny, rainy, cloudy, stormy, etc.
    intensity: float  # 0.0 to 1.0
    effects: Dict[str, float]  # wpływ na różne aspekty gry
    description: str

@dataclass
class ResourceNode:
    """Klasa reprezentująca źródło zasobów w lokacji."""
    type: str  # ore, herbs, wood, etc.
    resource_id: str
    quantity: int
    respawn_time: int  # w minutach
    last_harvested: float = 0.0
    required_skill: Optional[str] = None
    required_skill_level: int = 0

class Location:
    def __init__(self, loc_id: str, data: dict):
        self.id = loc_id
        self.name = data['name']
        self.description = data['description']
        self.items = list(data.get('items', []))
        self.exits = list(data.get('exits', []))
        self.level_requirement = data.get('level_requirement', 1)
        self.danger_level = data.get('danger_level', 1)
        self.type = data.get('type', 'neutral')  # neutral, safe, dangerous, dungeon
        self.npcs = npcs = data.get('npcs', []) # lista ID NPC w lokacji 
        # Zaawansowane właściwości
        self.weather: Optional[Weather] = None
        self.resources: List[ResourceNode] = []
        self.discovered = False
        self.events = data.get('events', [])
        self.npcs = set(data.get('npcs', []))
        self.enemies = set(data.get('enemies', []))
        self.buildings = data.get('buildings', {})
        self.quest_triggers = data.get('quest_triggers', [])
        
        # Dynamiczne właściwości
        self.active_events = set()
        self.temporary_npcs = set()
        self.visited_count = 0
        self.last_visited = 0.0
        
        self._initialize_resources(data.get('resources', []))
        self._initialize_weather()

    def _initialize_resources(self, resource_data: List[dict]):
        """Inicjalizuje źródła zasobów w lokacji."""
        for res_data in resource_data:
            self.resources.append(ResourceNode(
                type=res_data['type'],
                resource_id=res_data['id'],
                quantity=res_data['quantity'],
                respawn_time=res_data['respawn_time'],
                required_skill=res_data.get('required_skill'),
                required_skill_level=res_data.get('required_skill_level', 0)
            ))

    def _initialize_weather(self):
        """Inicjalizuje system pogody dla lokacji."""
        weather_types = {
            'sunny': {
                'description': 'Słoneczna pogoda',
                'effects': {'visibility': 1.2, 'movement_speed': 1.1}
            },
            'rainy': {
                'description': 'Pada deszcz',
                'effects': {'visibility': 0.8, 'movement_speed': 0.9}
            },
            'stormy': {
                'description': 'Szaleje burza',
                'effects': {'visibility': 0.6, 'movement_speed': 0.7, 'combat_accuracy': 0.8}
            }
        }
        
        # Losowy wybór pogody z uwzględnieniem typu lokacji
        weather_type = random.choice(list(weather_types.keys()))
        weather_data = weather_types[weather_type]
        
        self.weather = Weather(
            type=weather_type,
            intensity=random.uniform(0.5, 1.0),
            effects=weather_data['effects'],
            description=weather_data['description']
            
    
        )

    def add_item(self, item_id: str):
        if item_id not in self.items:
            self.items.append(item_id)

    def remove_item(self, item_id: str):
        if item_id in self.items:
            self.items.remove(item_id)

    def add_npc(self, npc_id: str):
        if npc_id not in self.npcs:
            self.npcs.append(npc_id)

    def remove_npc(self, npc_id: str):
        if npc_id in self.npcs:
            self.npcs.remove(npc_id)


    def update(self, game_time: float):
        """Aktualizuje stan lokacji."""
        # Aktualizacja zasobów
        for resource in self.resources:
            if resource.quantity < 1 and (game_time - resource.last_harvested) >= resource.respawn_time:
                resource.quantity = random.randint(1, 3)

        # Aktualizacja pogody
        if random.random() < 0.1:  # 10% szansa na zmianę pogody
            self._initialize_weather()

        # Sprawdzanie i aktywacja wydarzeń
        self._check_events(game_time)

    def _check_events(self, game_time: float):
        """Sprawdza i aktywuje wydarzenia w lokacji."""
        for event_data in self.events:
            event_id = event_data['id']
            if event_id not in self.active_events:
                if self._should_trigger_event(event_data, game_time):
                    self.active_events.add(event_id)
                    logger.info(f"Aktywowano wydarzenie {event_id} w lokacji {self.name}")

    def _should_trigger_event(self, event_data: dict, game_time: float) -> bool:
        """Sprawdza czy wydarzenie powinno zostać aktywowane."""
        # Sprawdzenie warunków czasowych
        if 'time_condition' in event_data:
            time_condition = event_data['time_condition']
            if not self._check_time_condition(time_condition, game_time):
                return False

        # Sprawdzenie warunków pogodowych
        if 'weather_condition' in event_data:
            if event_data['weather_condition'] != self.weather.type:
                return False

        # Sprawdzenie innych warunków
        probability = event_data.get('probability', 1.0)
        return random.random() < probability

    def _check_time_condition(self, condition: dict, game_time: float) -> bool:
        """Sprawdza warunki czasowe dla wydarzenia."""
        # Implementacja sprawdzania warunków czasowych
        return True  # Tymczasowo zawsze True

    def add_temporary_npc(self, npc_id: str, duration: float):
        """Dodaje tymczasowego NPC do lokacji."""
        self.temporary_npcs.add(npc_id)
        # Tutaj można dodać logikę usuwania NPC po określonym czasie

    def remove_temporary_npc(self, npc_id: str):
        """Usuwa tymczasowego NPC z lokacji."""
        self.temporary_npcs.discard(npc_id)

    def get_all_npcs(self) -> Set[str]:
        """Zwraca wszystkich NPC w lokacji."""
        return self.npcs.union(self.temporary_npcs)

    def can_enter(self, player) -> tuple[bool, str]:
        """Sprawdza czy gracz może wejść do lokacji."""
        if player.level < self.level_requirement:
            return False, f"Wymagany poziom: {self.level_requirement}"
        return True, ""

    def get_location_info(self) -> dict:
        """Zwraca pełne informacje o lokacji."""
        return {
            'name': self.name,
            'description': self.description,
            'weather': f"{self.weather.description} (intensywność: {self.weather.intensity:.1f})",
            'danger_level': self.danger_level,
            'exits': self.exits,
            'resources': [
                f"{r.type} (ilość: {r.quantity})" for r in self.resources if r.quantity > 0
            ],
            'active_events': list(self.active_events),
            'npcs': list(self.get_all_npcs())
        }

class World:
    def __init__(self, data_file: str = 'data/world.json'):
        self.locations: Dict[str, Location] = {}
        self.current_time: float = 0.0
        self.active_events: Dict[str, dict] = {}
        self.weather_system_enabled = True
        self._load_world(data_file)

    def _load_world(self, data_file: str):
        """Ładuje dane świata z pliku."""
        try:
            with open(data_file, 'r', encoding='utf-8') as f:
                data = json.load(f)
                world_data = data['world']['locations']
                for loc_id, loc_data in world_data.items():
                    # Przekazujemy wszystkie dane jako pojedynczy słownik
                    self.locations[loc_id] = Location(loc_id, loc_data)
            logger.info(f"Załadowano {len(self.locations)} lokacji")
        except Exception as e:
            logger.error(f"Błąd podczas ładowania świata: {e}")
            raise

    def get_location(self, loc_id: str) -> Optional[Location]:
        """Pobiera lokację po ID."""
        return self.locations.get(loc_id)

    def update(self, game_time: float):
        """Aktualizuje stan świata."""
        self.current_time = game_time
        for location in self.locations.values():
            location.update(game_time)
        self._update_global_events(game_time)

    def _update_global_events(self, game_time: float):
        """Aktualizuje globalne wydarzenia w świecie."""
        # Implementacja globalnych wydarzeń
        pass

    def discover_location(self, loc_id: str):
        """Oznacza lokację jako odkrytą."""
        if loc_id in self.locations:
            self.locations[loc_id].discovered = True

    def get_connected_locations(self, loc_id: str) -> List[str]:
        """Zwraca listę lokacji połączonych z daną lokacją."""
        if loc_id in self.locations:
            return self.locations[loc_id].exits
        return []

    def get_safe_locations(self) -> List[str]:
        """Zwraca listę bezpiecznych lokacji."""
        return [loc_id for loc_id, loc in self.locations.items() 
                if loc.type == 'safe']

    def get_dangerous_locations(self) -> List[str]:
        """Zwraca listę niebezpiecznych lokacji."""
        return [loc_id for loc_id, loc in self.locations.items() 
                if loc.type == 'dangerous']